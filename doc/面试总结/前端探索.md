[toc]

## Web Components

Custom elements 自定义元素

- 一组JavaScript API，允许您定义custom elements及其行为，然后可以在您的用户界面中按照需要使用它们

页面导入

- 已废弃

Shadow DOM

- 一组JavaScript API，用于将封装的“影子”DOM树附加到元素（与主文档DOM分开呈现）并控制其关联的功能。通过这种方式，您可以保持元素的功能私有，这样它们就可以被脚本化和样式化，而不用担心与文档的其他部分发生冲突。

HTML templates  HTML模板

-  <template> 和 <slot> 元素使您可以编写不在呈现页面中显示的标记模板。然后它们可以作为自定义元素结构的基础被多次重用。

## webassembly

- WebAssembly是一种运行在现代网络浏览器中的新型代码，并且提供新的性能特性和效果。它设计的目的不是为了手写代码而是为诸如C、C++和Rust等低级源语言提供一个高效的编译目标。
- WebAssembly 的到来扩展了仅仅用开放的 Web 平台技术就可以实现的应用程序的范围。在当今机器学习和人工智能越来越普遍的世界中，重要的是在不损害用户安全性的情况下在 Web 上运行高性能程序
- WebAssembly 是虚拟机和执行环境，可以让加载的页面作为本机编译代码运行，从而提高了 Web 性能和功耗。

## Serverless

从字面上来看就是 server less的意思，少服务或者轻服务的概念，比较准确的就是 是应用开发不需要关心服务器的部署和配置。它是将服务端运维高度抽象成一种解决方案。从架构的角度上，`serverless = Faas + Trigger+ Baas = Serverless Computing 无服务器计算`

🍊 优势

1. 专注业务，快速迭代： 无需关系服务器的状态，这是他的一大优势。
2. 提高服务器利用率，自动扩缩容，业务高峰自动扩容，业务降低自动收缩，降低资源浪费
3. 节省维护和运维成本：无需预估线上服务资源，也无需单独配置服务器资源
4. 降低风险：将系统分为不同模块进行独立管理，例如存储、网关、路由等，类似于微前端

🍊 缺点

1. 状态管理能力弱，为了保证自动扩缩容，FaaS必须是无状态的，有状态的需要BaaS的支持
2. 调试困难，有些保存不太容易定位是本地环境还是云环境
3. 延迟，因为是冷启动，而且应用程序是高度分布式和低耦合的，导致启动延迟问题

🍊 构建流程

Serverless架构是一种全新的软件架构方式，虽然其有各种各样独有的特点，但是Serverless应用和传统的软件应用一样，软件的设计、开发到交付需要经历一个完整的软件生命周期，需要通过具体的手段保证应用的交付质量。敏捷开发拥抱变化、持续改进以及快速迭代的思想在Serverless应用开发的过程中将仍然适用。Serverless应用的交付质量将受益于敏捷开发所使用的具体工具和方法，如结对编程（Pair Programing）、测试驱动开发（Test-driven Development，TDD）以及持续集成与交付（CICD）等。

1. 开发调试
2. 单元测试
3. 持续继承
4. 应用部署

🍊 冷启动

在Serverless Computing世界中，函数是按需运行的，如果没有请求，就不会有函数实例占用函数服务资源。从调用函数开始到函数实例准备完成的整个过程，被称为**冷启动**。冷启动代表着代码首次执行时所消耗的时长。这意味着相关代码需要进行下载、启动容器、启动及运行准备。

四个阶段

1. 下载代码： FaaS平台不会存储代码，这也是为了能够缩容到 0 。代码实际上会被存储在服务中，在冷启动过程中会从存储服务中下载代码。
2. 启动容器：代码下载完后，FaaS会根据函数的配置，启动对应的容器。也正是通过容器技术，FaaS可保证每个函数的独立性。
3. 初始化运行环境：分析代码依赖、执行用户初始化逻辑、初始化入口函数之外的代码等操作。
4. 运行代码：调用入口函数执行代码。这个过程比较特殊，可能是冷启动，也可能是热启动。

🍊 为什么要对冷启动要进行优化呢 ？

1. 通过上面冷启动时间排行可以看到，最优的是nodejs，启动事件也在200ms左右。本地函数和云函数的调用是不一样的，本地函数是随着调用立即响应的，不会有延迟问题，而云函数部署计算运行环境，这个过程需要几百毫秒的时间，在对延迟有特殊要求的场景时可能会导致超时等问题的。
2. 云函数是有自动扩容的特点的，在没有调用的时候它会极致的缩容到0，或者少调用量时会进行资源的回收清除，而调用量新增是又会触发冷启动，这个过程是反复进行的。

冷启动耗时大头主要是以下三方面

1. 虚拟机和容器的创建过程，传统的虚拟机创建通常需要分钟的级别，容器需要秒的级别
2. 函数代码的下载过程，主要取决于代码的大小，下载耗时从几十毫秒到几秒不等
3. VPC网络的打通过程，主要是部署弹性网卡和路由下发的过程，通常耗时秒级别

优化方案

- 减少代码体积：
  - 开发者可以通过精简代码，删除无用依赖，加速下载函数代码过程
  - 比如腾讯云对代码做了两级的缓存，可以有效降低下载代码时间
- 资源复用，缩短函数执行时间
- 选择冷启动时间较少的语言
- 选择合适的内存：函数内存越大，冷启动表现越优
- 避免不必要的配置
- 降低冷启动频率
  - 使用定时触发器定时访问函数，这样可以防止函数实例一段时间没被使用被销毁
  - 使用 initializer 函数入口，函数计算会异步调用初始化接口，消除初始化用户代码的时间
- 预留实例

## 微前端

🍊 路由分发式微前端

通过路由将不同的业务分发到不同且独立的前端应用上。主要是通过HTTP的反向代理或者nginx来进行处理，但是这种方式仅能满足共享整个页面的功能。

🍊 iframe

通过HTML的内联框架iframe标签来实现。它能有效的将一个页面嵌入到另一个页面中，并且两个页面家你的css和js是相互隔离的。但是它存在很多问题：

1. **不可控制**： `iframe`嵌入的显示区大小不容易控制，存在一定的局限性

2. **bfccache**：URL记录完全失效，页面刷新不能被记忆，刷新会返回首页，`iframe`功能之间跳转也无效

3. **兼容性大坑**：`iframe`的样式显示、兼容性等都具有局限性，尤其是在移动端

4. **性能开销**：`iframe`阻塞`onload`、占用连接池、多层嵌套页面崩溃等

5. **SEO**：不支持SEO搜索

🍊 微件化

通过一个**新的构建系统**，将部分业务功能组件构建成一个独立的chunk代码，使用时只需远程加载即可。那么重点就是这个新的构建系统，它要提供**一套应用注册机制**，完成功能组件的无缝整合、构建时集成应用和应用**独立发布部署**、一套本地或者远程**加载机制**。

🍊 应用组件化

借助于`Web Components`技术，来构建跨框架的前端应用。`Web Components`允许开发者创建可重用的定制元素，并在web应用中使用它们。但是真正在项目中使用`Web Components`技术还不太理想，各大浏览器的兼容程度还不太理想，不过可以借助polyfill来解决。它是一种面向未来演进的架构，当它实现兼容后，`Vue`、`React`、`Angular`框架也就淘汰了。

不论是基于Web Components的Angular，还是Virtual DOM的React，都是因为现有的前端框架都离不开基本的HTML元素DOM。

🍊 qiankun

它是基于single-spa的二次封装，使微应用的接入更加便捷、简单。

1. **HTML Entry**：使用`import-html-entry`通过 `http` 请求加载指定地址的首屏内容即 `html` 页面，解决single-spa的js entry带来的问题。
2. **样式隔离**：① 严格的样式隔离，每个微应用都被容器包裹在一个shadow dom节点，保证不会互相影响；② 通过实验性的css scope方式，动态的改写css选择器。
3. 运行时沙箱：分为js沙箱和样式沙箱。①JS沙箱为每个微应用生成单独的window proxy对象，配合HTML Entry提供的js脚本执行器实现js隔离；② 样式沙箱：通过重写dom操作的方式，劫持动态样式和js脚本的添加，微应用的插入到微应用模版，并且为劫持的动态样式做了 `scoped css` 的处理，为劫持的脚本做了 JS 隔离的处理

4. **资源预加载**：两种预加载的思路① 当主应用执行start方法启动qiankun以后立即预加载微应用的静态资源②在第一个微应用挂载以后预加载其他微应用的静态资源。这些都是利用single-spa提供的`single-spa:first-mount`事件来实现的。
5. **应用间通信**：qiankun通过发布订阅的方式实现应用间通讯的，状态是框架统一维护的，提供了一些列的api来实现应用的状态更改和订阅，并进行状态间的传递。

