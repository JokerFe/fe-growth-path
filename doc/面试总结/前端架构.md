[toc]

## 中台

> 中台的一个重要的特性是【复用】，但是复用程度不一定很高，但一定具有某种特有的业务内容或者技术形态。

分类

1. 技术型：消息队列、告警中心等
2. 业务型：电商的支付中心、订单、会员服务等
3. 数据型：用户画像、用户日志、用户物料等
4. 算法型：语音识别、推荐算法等

价值

中台存在的意义一定是调高效率，一定要稳定，一切的本质是不能影响业务的发展。

总结

作为前端开发，要想更加深入中台，可以尝试从这三个关键字入手：微前端、业务、数据。

微前端：本来是一种利用微件拆分来达到工程拆分治理的方案，可以解决工程膨胀、开发维护困难等问题。它的特性正好和中台是契合的。中台的复用性决定，它的业务来自于业务线，并且会分成一个一个模块。这些模块之间是不能有太复杂的联系的，所以它可以分布在不同的系统。使用微前端来开发中台，是再好不过了。

业务：中台的业务是和每个接入中台的业务线都有关系的，想要更好的理解中台，就需要先理解每个业务线的业务。不然开发的时候，你很难预料到会出现什么问题。前端对比后端来说，业务上是比较薄弱的，从数据提交到后台之后，前端就不知道具体的业务流程了。这个只能多和后端、产品沟通来弥补自身的不足。

数据：前端使用的数据一般都是后端提供的接口，对整体的业务模型并没有一个概念，这会导致你很难估量一个数据模型修改带来的成本。前台业务的话，大部分并不复杂，流程比较清晰，基本拿到数据就知道业务了。但是中台却不一样（其实后台也是），当你创建了一个商品，可能这个商品需要去几个系统同步各种数据，这些数据间还会存在关系。有些数据，可能你都不知道它有什么作用。以公司ISS的商品为例1，商品需要关联一个物料编码，这个物料编码会和SAP物料有关联，最后关联到物料的价格上。如果你不知道这个数据的意义，那你就没发回答商品怎么配置价格的问题。

## BFF架构

> BFF （Backends For Frontends） 服务于前端的后端，目的时为了解决多端的业务耦合的问题。

实际应用中，我们会为每个端设计相应的BFF，每个端的 **BFF** 处理自身的业务逻辑，需要数据时从 基础服 务 内获取，然后在接口返回之前进行组装数据用于实例化返回对象。

BFF的缺点

*  响应时间延迟(服务如果是内网之间访问，延迟时间较低)。
*  增加了代码量，编写起来较为浪费时间(因为在基础服务上添加的一层转发，所以会多写一部分代
    码)。
*   业务异常处理(统一格式化业务异常的返回内容)。
*   分布式事务(微服务的通病)。

应用场景

1. Node中间层
2. 天然支持跨域
3. SSR
4. 首页服务端渲染+切页SPA

项目具体内容

1. 服务端自动重启：nodemon、pm2、docker
2. 服务端路由：koa-router 、@koa/router、koa-simple-router
3. 页面模板：koa-swig（koa2需接口co使用）
4. 静态资源处理：koa-staitc
5. History路由刷新问题（真假路由）：koa2-connect-history-api-fallback
6. 容错：node服务是很脆弱的，要讲所有可能出错的地方都进行捕获和处理（JS，接口，请求，取值等），最好是能结合TS去使用
7. 模块化： 使用system解决浏览器不支持的问题
8. 前端框架： 使用vue\react创建项目，通过命令进行copy，结合static服务使用
9. 日志服务： log4js进行日志输出，可进行时间、级别、和分类
10. Node代码模块化改造：commonJS => ES6Module，用ES6Module的方式去写node 代码。开发环境可使用@babel/node、@babel/preset-env
11. 压测：playwight，rizepupter；
12. e2e测试：模拟用户操作，mocha、chai、supertest（请求接口）

## monorepo和mutirepo区别

monorepo

- 将相关相关的所有内容都放在一个仓库里
- 比如react vue3 babel等
- 便于统一的工作方式和流程，团队协作效率提升
- 能对整体项目有全面的理解
- 问题
- 需要强大的构建工具，保证项目构建的效率
- 文件夹的权限等控制问题
- 项目规范的挑战，需要强大的review
- 巨石应用的倾向

multirepo

- 是不同的模块放在不同的仓库去管理
- 每个团队可以使用自己擅长的工具、习惯去开发，多元化的工作方式能使各个团队尽可能的提升自己的效率，独立的发布上限方便权限控制与安全性
- 问题
- 版本管理，规范等
- 如果某个库中发现了一个bug，就必须到目标库里去修复、打包、发布，然后主项目升级后才能继续工作。这要么需要你熟悉这个库，或者等待维护同学去修复，这个时间成本也会很高
- 比如我们的业务组件，是独立于每个业务项目的，如果有bug 或者小改动，首先要去组件库去修改、自测、打包、测试版本发布后，业务项目才能使用，然后进行进一步的业务功能测试（这个功能还可能影响其他业务线的功能），一整套流程是比较长的。这个需要结合业务去衡量，去保证收益大于维护成本。
- 业务组件的一个解决方案就是：业务组件来实现通用功能和样式，产品线特殊逻辑通过hooks或者callback来实现业务逻辑的插入

monorepo的项目增多会导致ts的lint或者编译变慢

- [参考git的稀疏检出和浅克隆的办法](https://www.worldhello.net/gotgit/08-git-misc/090-sparse-checkout-and-shallow-clone.html)
- 稀疏检出
  - 从1.7.0版本开始Git提供稀疏检出的功能。所谓稀疏检出就是本地版本库检出时不检出全部，只将指定的文件从本地版本库检出到工作区，而其他未指定的文件则不予检出（即使这些文件存在于工作区，其修改也会被忽略）。
  - 要想实现稀疏检出的功能，必须同时设置core.sparseCheckout配置变量，并存在文件.git/info/sparse-checkout。即首先要设置Git配置变量core.sparseCheckout为true，然后编辑.git/info/sparse-checkout文件，将要检出的目录或文件的路径写入其中。其中文件.git/info/sparse-checkout的格式就和.gitignore文件格式一样，路径可以使用通配符。
- 稀疏检出是如何实现的
  - Git在index（即暂存区）中为每个文件提供一个名为skip-worktree标志位，缺省这个标识位处于关闭状态。如果该标识位开启，则无论工作区对应的文件存在与否，或者是否被修改，Git都认为工作区该文件的版本是最新的、无变化。Git通过配置文件.git/info/sparse-checkout定义一个要检出的目录和/或文件列表，当前Git的git read-tree命令及其他基于合并的命令（git merge，git checkout等等）能够根据该配置文件更新index中文件的skip-worktree标志位，实现版本库文件的稀疏检出。
- 浅克隆
  - 只需要在执行git clone或者git fetch操作时用--depth <depth>参数设定要获取的历史提交的深度（<depth>大于0），就会把源版本库分支上最近的<depth> + 1个历史提交作为新版本库的全部历史提交。
- https://www.worldhello.net/gotgit/08-git-misc/090-sparse-checkout-and-shallow-clone.html
- ts的Project Reference方式
  - 在子项目中各自创建tsconfig.json，进行各自项目的独立编译配置
  - 通过reference引入这些独立的模块的编译配置，然后通过tsc -build的方式进行编译

## 前端工程化

流程

- 开发规范
  - css hint
  - html hint
  - ESlint
- 模块化开发
  - 资源模块化
  - css的模块化，包含BEM 
  - js模块化
- 组件开发
  - 每个包含模板(HTML)+样式(CSS)+逻辑(JS)功能完备的结构单元统前端框架/类库的思想是先组织DOM
  - 然后把某些可复用的逻辑封装成组件来操作DOM，是DOM优先;而组件化框架/类库 的思想是先来构思组件
  - 然后用DOM这种基本单元结合相应逻辑来实现组件，是组件优先。
  - 现在 可以先分文件夹再甚至用Vue等定义进一步细致的组件
- 组件仓库
  - git
  - svn
- 性能优化
  - 自动化压缩合并打包加戳
  - 预编译和资源注入
  - ES6/7语法转译
  - css预编译器处理
  - 雪碧图
- 部署
- 开发流程
  - code review
  - bug收集
  - 敏捷开发
  - 文件监听
  - 动态编译
- 开发文档
  - jsDoc
- 自动化测试

工程化及持续集成

- 构建工具
  - webpack
  - gulp
  - rollup
- 版本管理
  - gitlab
  - git
  - svn
- 日志管理
  - log4js
- 文档管理
  - jsDoc
- 代码规范
  - ESLint
  - HTML Hint
  - CSS Hint
- 持续集成
  - Jenkins
  - Travis

