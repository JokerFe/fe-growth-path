[toc]

## 浏览器是如何运作的

浏览器可以简单分为三块：**用户界面**、**浏览器引擎**、**渲染引擎**。

**用户界面**用于展示除标签页窗口之外的其他用户界面内容。**渲染引擎**负责渲染用户请求的页面。在用户界面和渲染引擎之间有一个**浏览器引擎**，用于在用户界面和渲染引擎之间传递数据。

渲染器下面还有很多小的功能模块，比如：负责网络请求的网络模块、用于解析和执行js的js解释器、还有数据存储持久层帮助浏览器存储各种数据（eg:cookie）。

渲染引擎可以说是一个浏览器的核心与灵魂。我们往往会把渲染引擎叫做浏览器的内核，不同浏览器使用的内核也不太一样。其中IE使用的是Trident、Firefox使用的Gecko、Safari使用的是Webkit并将其开源、Chrome是使用的基于webkit改造优化的Blink渲染引擎也将其开源、Opera和Edge使用的是Blink。可以看到Webkit项目的开源对浏览器的发展做了多大的贡献。

浏览器是运行在操作系统上的一个应用程序，每个应用程序必须至少启动一个进程来执行其功能，每个程序往往需要运行很多任务，进程就会创建一些线程来帮助它去执行这些小的任务。

>  **进程**是操作系统进行资源分配和调度的基本单元，可以申请和拥有计算机资源，进程是程序的基本执行实体。
>
>  **线程**是操作系统能够进行运算调度的最小单位，一个进程中可以并发多个线程，每条线程并行执行不同的任务。

当我们启动某个程序时就会创建一个进程来执行任务代码，同时会为该进程分配内存空间，该应用程序的状态都保存在该内存空间里。当应用关闭时，该内存空间就会被回收。进程可以启动更多的进程来执行任务，由于每个进程分配的内存空间是独立的，如果两个进程间需要传递某些数据，则需要进程间通讯管道IPC来传递。很多应用程序都是多进程的结构，这样是为了避免某一个进程卡死，由于进程间的相互独立，这样就不会影响到整个应用程序。进程可以将任务分成更多细小的任务，然后通过创建多线程并行执行不同的任务。同一进程下的线程之间是可以直接通信共享数据的。

早期的浏览器并不是多进程的结构，而是一个单进程的结构，一个进程中大概有页面线程负责页面渲染和展示等，js线程执行js代码，还有其它各种线程。单进程的结构引发了很多问题：一是**不稳定**，其中一个线程的卡死可能会导致整个进程出问题，比如打开多个标签页，其中一个标签卡死可能会导致整个浏览器无法正常运行；二是**不安全**，浏览器之间是可以共享数据的，那js线程岂不是可以随意访问浏览器进程内的所有数据；三是**不流畅**，一个线程需要负责太多事情会导致运行效率的问题。所以为了解决以上这些问题，现在采用了多进程浏览器结构。根据不同进程功能来拆卸浏览器，我们可以将它分解为这样的结构：其中**浏览器进程**负责控制Chrome浏览器出标签页外的用户界面，包括地址栏、书签、后退和前进按钮，以及负责与浏览器的其他进程协调工作；**网络进程**负责发起接受网络请求；**GPU进程**负责整个浏览器界面的渲染；插件进程负责控制网站使用的所有插件，例如flash，这里的插件指的不是chrome应用市场的插件；渲染器进程用来控制显示tab标签内的所有内容，浏览器会在默认情况下为每个标签页创建一个进程（再启动chrome是可以选择进程模型，它有四种进程模型）

当在浏览器地址栏输入网络地址时，浏览器进程的UI线程会捕捉你的输入内容，如果访问的是网址则UI线程会启动一个网络线程来请求DNS进行域名解析，接着开始连接服务器获取数据；如果输入的不是网址而是一串关键词，浏览器就知道你是要搜索，于是就会使用默认配置的渲染引擎来查询。

**浏览器安全验证：**当网络线程获取到数据后会通过SafeBrowsing来检查站点是否是恶意站点，如果是则会提示警告页面，告诉你这个站点有安全问题，浏览器会阻止你的访问，当然也可以强行继续访问。SafeBrowsing是谷歌内部的一套站点安全系统，通过检测该站点的数据来判断是否安全，比如查看该站点的IP是否在谷歌的黑名单之内，当返回数据准备完毕并且安全校验通过时，网络线程会通知UI线程我准备好了。然后UI线程会创建一个渲染器进程Renderer Thread来渲染页面，浏览器进程通过IPC管道将数据传递给渲染器进程，正式进入渲染流程。

**DOM树构建：**渲染器进程接受到的数据也就是HTML。渲染器进程的核心任务就是把html、css、js、image等资源渲染成用户可以交互的web页面。渲染器进程的主线程将html进行解析，构造DOM数据结构。DOM也就是文档对象模型，是浏览器对页面在其内部的表示形式，是web开发程序员可以通过JS与之交互的数据结构和API。html首先通过tokeniser标记化，通过词法分析将输入的html内容解析成多个标记，根据识别后的标记进行DOM树构造，在DOM树构建过程中会创建document对象，然后以document的为根节点的DOM树，不断进行修改，向其中添加各种元素。

**渲染阻塞：**html代码中往往会引入一些额外的资源，比如图片、CSS、JS脚本等，图片和CSS这些资源需要通过网络下载或从缓存中直接加载，这些资源不会阻塞html的解析，因为他们不会影响DOM树的生成，但当HTML解析过程中遇到script标签，就会停止html解析流程，转而去加载解析并且执行JS。这是因为浏览器并不知道JS执行是否会改变当前页面的HTML结构，如果JS代码里用了document.write方法来修改html，之前的和html解析就没有任何意义了，这也就是为什么我们一直说要把script标签要放在合适的位置，或者使用async或defer属性来异步加载执行JS。

**Layout Tree：**在html解析完成后，我们就会获得一个DOM Tree（树），但我们还不知道DOM Tree上的每个节点应该长什么样子，主线程需要解析CSS，并确定每个DOM节点的计算样式，即使你没有提供自定义的CSS样式，浏览器会有自己默认的样式表，比如h2的字体要比h3的大。在知道DOM结构和每个节点的样式后，我们接下来需要知道每个节点需要放在页面上的哪个位置，也就是节点的坐标以及该节点需要占用多大的区域，这个阶段被称为layout布局，主线程通过遍历dom和计算好的样式来生成Layout Tree。Layout Tree上的每个节点都记录了x、y坐标和边框尺寸。这需要注意的是DOM Tree和Layout Tree并不是一一对应的，设置了display:none的节点不会出现在Layout Tree上，而在before伪类中添加了content值的元素content中的内容会出现在Layout Tree上，不会出现在DOM树里，这是因为DOM是通过HTML解析获得的，并不关系样式，而Layout Tree是根据DOM和计算好的样式来生成，Layout Tree是和最后展示在屏幕上节点是对应的。

**绘制（paint）：**现在我们已经知道了元素的大小形状和位置，但还不知道以什么样的顺序绘制（paint）这个节点，例如z-index这个属性会影响节点绘制的层级关系，如果按照dom的层级结构来绘制页面则会导致错误的渲染。所以为了保证在屏幕上展示正确的层级，主线程遍历Layout Tree创建一个绘制记录表（Paint Record），该表记录了绘制的顺序，这个阶段配称为绘制（Paint）。

**栅格化：**现在知道了文档的绘制顺序，终于到了该把这些信息转化成像素点显示在屏幕上了，这个行为被称为栅格化（Rastering）。chrome最早使用了一种很简单的方式，只栅格化用户可视区域的内容，当用户滚动页面时，再栅格化更多的内容来填充缺失的部分，这种方式带来的问题就是会导致展示延迟。现在chrome进行了优化升级，使用了一种更为复杂的栅格化流程叫做合成（compositing），合成是一种将页面各个部分分成多个图层，分别对其进行栅格化，并在合成器线程（compositor Thread）中单独进行合成页面，简单来说就是页面所有的元素按照某种规则进行分图层，并把图层都栅格化好了，然后只需要把可视区的内容组合成一帧展示给用户即可。

**layer tree：**主线程遍历Layout Tree生成layer tree，当Layer Tree生成完毕和绘制顺序确定后，主线程将这些信息传递给合成器线程，合成器线程将每个图层栅格化，由于一层可能想页面的整个长度一样大，因此合成器线程将他们切分为许多图块（tiles），然后将每个图块发送给栅格化线程（Raster Thread），栅格化线程栅格化每个图块，并将他们存储在GPU内存中，当图块栅格化完成后，合成器线程将收集成为 draw quads 的图块信息，这些信息里记录了图块字啊内存中的位置和在页面的那个位置绘制图块的信息，根据这些信息合成器线程生成一个合成器帧（Compositor Frame）然后合成器Frame（帧）通过IPC传递给浏览器进程，接着浏览器进程将合成器帧传送到GPU，然后GPU渲染展示到屏幕上。

当页面发生变化时，比如滚动了当前的页面，都会生成一个新的合成器帧，新的帧再传给GPU，然后再次渲染到屏幕上。

**总结：**浏览器进程中的网络线程请求获取到html数据后，通过IPC将数据传给渲染器进程的主线程，主线程将html解析构造DOM树，然后进行样式计算，根据DOM树和生成好的样式生成Layout Tree，通过遍历Layout Tree生成绘制顺序表，接着遍历Layout Tree生成layer tree，然后主线程将Layer Tree和绘制顺序表一起传给合成器线程，合成器线程按规则进行分图层，并把图层分为更小的图块（tiles）传给栅格化线程进行栅格化，栅格化完成后，合成器线程会获得栅格线程传过来的draw quads图块信息，根据这些信息合成器线程上合成了一个合成器帧，然后将该合成器帧通过IPC传回给浏览器进程，浏览器进程再传递给GPU进行渲染之后就展示到你的屏幕上。

**重绘重排：**当我们改变了一个元素的尺寸位置属性时，会重新进行样式计算（computed style）布局（layout）绘制（paint）以及后面的所有流程，这种行为成为重排。当改变了某个元素的颜色属性时不会重新触发布局，但还是会触发样式计算和绘制这就是重绘，我们可以发现重排和重绘都会占用主线程，还有JS也会运行在主线程，所以就会出现抢占执行时间的问题，如果你写了一个不断导致重排重绘的动画，浏览器则需要在每一帧都运行样式计算布局和绘制的操作。

**优化：**我们知道当前页面以每秒60帧的刷新率时才不会让用户感觉到页面卡顿，如果在运行动画是还有大量的JS任务需要执行，因为布局、绘制和js执行都是在主线程运行的，当在一帧的时间内布局和绘制结束后，还有剩余时间js就会拿到主线程的使用权，如果js执行时间过长，就会导致在下一帧开始时js没有及时归还主线程，导致下一帧动画没有按时渲染，就会出现页面的卡顿。

第一种优化方式：requestAnimationFrame，它会在每一帧被调用，通过回调API的回调，可以把js运行任务分成一些更小的任务块，在每一帧事件用完前暂停js执行归还主线程，这样的话在下一帧开始时，主线程就可以按时执行布局和绘制。  

第二种优化方式：栅格化的整个流程不占用主线程，只在合成器线程和栅格线程中运行，这就意味着它无需和js抢占主线程。如果反复进行重绘和重排可能会导致掉帧，这是因为有可能js执行阻塞了主线程，而CSS中有个动画属性transform，通过该属性实现的动画不会经过布局和绘制，而是直接运行在合成器线程和栅格线程，所以不会受到主线程中js执行的影响。更重要的是听过transform实现的动画由于不需要经过布局绘制样式计算等操作，所以节省了很多运算事件（方便实现负责的动画）

**CPU与GPU**:CPU和GPU作为计算机中最重要的两个计算单元直接决定了计算性能。**CPU**是计算机的大脑，负责处理各种不同的任务。在过去，大多数CPU是单芯片的，核心被安置在同一个芯片上。更新的CPU可以支持多核心，运算能力大大加强。而最新的的cpu已经达到10核心20线程数的能力了。**GPU**是另一个计算机的组成部分，与CPU不同，GPU更擅长利用多核心同时处理单一的任务。像命名那样，GPU最初被用于处理图像。这就是为什么使用GPU可以更快、更顺畅的渲染页面内容。随着GPU的发展，越来越多的计算任务也可以使用GPU来处理。甚至有人说GPU是人工智能的大功臣，可见GPU已经不再仅用于图像处理上了。

## 进程与线程的概念

从本质上说，进程和线程都是 CPU 工作时间片的一个描述：

- 进程描述了 CPU 在运行指令及加载和保存上下文所需的时间，放在应用上来说就代表了一个程序。

- 线程是进程中的更小单位，描述了执行一段指令所需的时间。

 **进程是资源分配的最小单位，线程是CPU调度的最小单位。**

 一个进程就是一个程序的运行实例。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫**进程**。**进程是运行在虚拟内存上的，虚拟内存是用来解决用户对硬件资源的无限需求和有限的硬件资源之间的矛盾的。从操作系统角度来看，虚拟内存即交换文件；从处理器角度看，虚拟内存即虚拟地址空间。**

 如果程序很多时，内存可能会不够，操作系统为每个进程提供一套独立的虚拟地址空间，从而使得同一块物理内存在不同的进程中可以对应到不同或相同的虚拟地址，变相的增加了程序可以使用的内存。

进程和线程之间的关系有以下四个特点：

 **（1）进程中的任意一线程执行出错，都会导致整个进程的崩溃。**

 **（2）线程之间共享进程中的数据。**

 **（3）当一个进程关闭之后，操作系统会回收进程所占用的内存，** 当一个进程退出时，操作系统会回收该进程所申请的所有资源；即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收。

 **（4）进程之间的内容相互隔离。** 进程隔离就是为了使操作系统中的进程互不干扰，每一个进程只能访问自己占有的数据，也就避免出现进程 A 写入数据到进程 B 的情况。正是因为进程之间的数据是严格隔离的，所以一个进程如果崩溃了，或者挂起了，是不会影响到其他进程的。如果进程之间需要进行数据的通信，这时候，就需要使用用于进程间通信的机制了。

![浏览器进程](/Users/guohaohao/Documents/github/fe-growth-path/imgs/性能优化/浏览器进程.png)

从图中可以看出，最新的 Chrome 浏览器包括：

- 1 个浏览器主进程

- 1 个 GPU 进程

- 1 个网络进程

- 多个渲染进程

- 多个插件进程

这些进程的功能：

- **浏览器进程**：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。
- **渲染进程**：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。
- **GPU 进程**：其实， GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。
- **网络进程**：主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。
- **插件进程**：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。

所以，**打开一个网页，最少需要四个进程**：1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程。如果打开的页面有运行插件的话，还需要再加上 1 个插件进程。

 虽然多进程模型提升了浏览器的稳定性、流畅性和安全性，但同样不可避免地带来了一些问题：

- **更高的资源占用**：因为每个进程都会包含公共基础结构的副本（如 JavaScript 运行环境），这就意味着浏览器会消耗更多的内存资源。

- **更复杂的体系架构**：浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了。

## 进程和线程的区别

- 进程可以看做独立应用，线程不能
- 资源：进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）；线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）。
- 通信方面：线程间可以通过直接共享同一进程中的资源，而进程通信需要借助 进程间通信。
- 调度：进程切换比线程切换的开销要大。线程是CPU调度的基本单位，线程的切换不会引起进程切换，但某个进程中的线程切换到另一个进程中的线程时，会引起进程切换。
- 系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存、I/O 等，其开销远大于创建或撤销线程时的开销。同理，在进行进程切换时，涉及当前执行进程 CPU 环境还有各种各样状态的保存及新调度进程状态的设置，而线程切换时只需保存和设置少量寄存器内容，开销较小。

### 浏览器渲染进程的线程有哪些

浏览器的渲染进程的线程总共有五种：

![浏览器原理2](/Users/guohaohao/Documents/github/fe-growth-path/imgs/性能优化/浏览器原理2.png)

**（1）GUI渲染线程** 负责渲染浏览器页面，解析HTML、CSS，构建DOM树、构建CSSOM树、构建渲染树和绘制页面；当界面需要**重绘**或由于某种操作引发**回流**时，该线程就会执行。

 注意：GUI渲染线程和JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。

**（2）JS引擎线程** JS引擎线程也称为JS内核，负责处理Javascript脚本程序，解析Javascript脚本，运行代码；JS引擎线程一直等待着任务队列中任务的到来，然后加以处理，一个Tab页中无论什么时候都只有一个JS引擎线程在运行JS程序；

 注意：GUI渲染线程与JS引擎线程的互斥关系，所以如果JS执行的时间过长，会造成页面的渲染不连贯，导致页面渲染加载阻塞。

**（3）事件触发线程** 事件**触发线程**属于浏览器而不是JS引擎，用来控制事件循环；当JS引擎执行代码块如setTimeOut时（也可是来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件触发线程中；当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理；

 注意：由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）；

**（4）定时器触发进程** **定时器触发进程**即setInterval与setTimeout所在线程；浏览器定时计数器并不是由JS引擎计数的，因为JS引擎是单线程的，如果处于阻塞线程状态就会影响记计时的准确性；因此使用单独线程来计时并触发定时器，计时完毕后，添加到事件队列中，等待JS引擎空闲后执行，所以定时器中的任务在设定的时间点不一定能够准时执行，定时器只是在指定时间点将任务添加到事件队列中；

 注意：W3C在HTML标准中规定，定时器的定时时间不能小于4ms，如果是小于4ms，则默认为4ms。

**（5）异步http请求线程**

- XMLHttpRequest连接后通过浏览器新开一个线程请求；

- 检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将回调函数放入事件队列中，等待JS引擎空闲后执行；

## 进程之间的通信方式

#### **（1）管道通信**

 管道是一种最基本的进程间通信机制。**管道就是操作系统在内核中开辟的一段缓冲区，进程1可以将需要交互的数据拷贝到这段缓冲区，进程2就可以读取了。**

 管道的特点：

- 只能单向通信

- 只能血缘关系的进程进行通信

- 依赖于文件系统

- 生命周期随进程

- 面向字节流的服务

- 管道内部提供了同步机制

#### **（2）消息队列通信**

 消息队列就是一个消息的列表。用户可以在消息队列中添加消息、读取消息等。消息队列提供了一种从一个进程向另一个进程发送一个数据块的方法。 每个数据块都被认为含有一个类型，接收进程可以独立地接收含有不同类型的数据结构。可以通过发送消息来避免命名管道的同步和阻塞问题。但是消息队列与命名管道一样，每个数据块都有一个最大长度的限制。

 使用消息队列进行进程间通信，可能会收到数据块最大长度的限制约束等，这也是这种通信方式的缺点。如果频繁的发生进程间的通信行为，那么进程需要频繁地读取队列中的数据到内存，相当于间接地从一个进程拷贝到另一个进程，这需要花费时间。

#### **（3）信号量通信**

 共享内存最大的问题就是多进程竞争内存的问题，就像类似于线程安全问题。我们可以使用信号量来解决这个问题。信号量的本质就是一个计数器，用来实现进程之间的互斥与同步。例如信号量的初始值是 1，然后 a 进程来访问内存1的时候，我们就把信号量的值设为 0，然后进程b 也要来访问内存1的时候，看到信号量的值为 0 就知道已经有进程在访问内存1了，这个时候进程 b 就会访问不了内存1。所以说，信号量也是进程之间的一种通信方式。

#### **（4）信号通信**

信号（Signals ）是Unix系统中使用的最古老的进程间通信的方法之一。操作系统通过信号来通知进程系统中发生了某种预先规定好的事件（一组事件中的一个），它也是用户进程之间通信和同步的一种原始机制。

#### **（5）共享内存通信**

 共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问（使多个进程可以访问同一块内存空间）。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。

####  **（6）套接字通信**

 上面说的共享内存、管道、信号量、消息队列，他们都是多个进程在一台主机之间的通信，那两个相隔几千里的进程能够进行通信吗？答是必须的，这个时候 Socket 这家伙就派上用场了，例如我们平时通过浏览器发起一个 http 请求，然后服务器给你返回对应的数据，这种就是采用 Socket 的通信方式了。

## 僵尸进程和孤儿进程是什么？

- **孤儿进程**：父进程退出了，而它的一个或多个进程还在运行，那这些子进程都会成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。
- **僵尸进程**：子进程比父进程先结束，而父进程又没有释放子进程占用的资源，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵死进程。

## 死锁产生的原因？ 如果解决死锁的问题？

所谓死锁，是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。

 系统中的资源可以分为两类：

- 可剥夺资源，是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺，CPU和主存均属于可剥夺性资源；

- 不可剥夺资源，当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自行释放，如磁带机、打印机等。

## 如何实现浏览器内多个标签页之间的通信?

实现多个标签页之间的通信，本质上都是通过中介者模式来实现的。因为标签页之间没有办法直接通信，因此我们可以找一个中介者，让标签页和中介者进行通信，然后让这个中介者来进行消息的转发。通信方法如下：

- **使用 websocket 协议**，因为 websocket 协议可以实现服务器推送，所以服务器就可以用来当做这个中介者。标签页通过向服务器发送数据，然后由服务器向其他标签页推送转发。
- **使用 ShareWorker 的方式**，shareWorker 会在页面存在的生命周期内创建一个唯一的线程，并且开启多个页面也只会使用同一个线程。这个时候共享线程就可以充当中介者的角色。标签页间通过共享一个线程，然后通过这个共享的线程来实现数据的交换。
- **使用 localStorage 的方式**，我们可以在一个标签页对 localStorage 的变化事件进行监听，然后当另一个标签页修改数据的时候，我们就可以通过这个监听事件来获取到数据。这个时候 localStorage 对象就是充当的中介者的角色。
- **使用 postMessage 方法**，如果我们能够获得对应标签页的引用，就可以使用postMessage 方法，进行通信。

## 对Service Worker的理解

Service Worker 是运行在浏览器背后的**独立线程**，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 **HTTPS**。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。

 Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 `install` 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。

## 对浏览器的缓存机制的理解

**浏览器缓存的全过程：**

- 浏览器第一次加载资源，服务器返回 200，浏览器从服务器下载资源文件，并缓存资源文件与 response header，以供下次加载时对比使用；
- 下一次加载资源时，由于强制缓存优先级较高，先比较当前时间与上一次返回 200 时的时间差，如果没有超过 cache-control 设置的 max-age，则没有过期，并命中强缓存，直接从本地读取资源。如果浏览器不支持HTTP1.1，则使用 expires 头判断是否过期；
- 如果资源已过期，则表明强制缓存没有被命中，则开始协商缓存，向服务器发送带有 If-None-Match 和 If-Modified-Since 的请求；
- 服务器收到请求后，优先根据 Etag 的值判断被请求的文件有没有做修改，Etag 值一致则没有修改，命中协商缓存，返回 304；如果不一致则有改动，直接返回新的资源文件带上新的 Etag 值并返回 200；
- 如果服务器收到的请求没有 Etag 值，则将 If-Modified-Since 和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回 304；不一致则返回新的 last-modified 和文件并返回 200；

![浏览器进程3](/Users/guohaohao/Documents/github/fe-growth-path/imgs/性能优化/浏览器进程3.png)

很多网站的资源后面都加了版本号，这样做的目的是：每次升级了 JS 或 CSS 文件后，为了防止浏览器进行缓存，强制改变版本号，客户端浏览器就会重新下载新的 JS 或 CSS 文件 ，以保证用户能够及时获得网站的最新更新。

## 浏览器资源缓存的位置有哪些？

资源缓存的位置一共有 3 种，按优先级从高到低分别是：

1. **Service Worker：Service Worker 运行在 JavaScript 主线程之外，虽然由于脱离了浏览器窗体无法直接访问 DOM，但是它可以完成离线缓存、消息推送、网络代理等功能。它可以让我们自由控制**缓存哪些文件、如何匹配缓存、如何读取缓存，并且**缓存是持续性的**。当 Service Worker 没有命中缓存的时候，需要去调用 `fetch` 函数获取 数据。也就是说，如果没有在 Service Worker 命中缓存，会根据缓存查找优先级去查找数据。**但是不管是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会先是从 Service Worker 中获取的内容。**
2. **Memory Cache：** Memory Cache 就是内存缓存，它的效率最快，**但是内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。**一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。
3. **Disk Cache：** Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache **胜在容量和存储时效性上。**在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。**并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。**

**Push Cache：** Push Cache 是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。并且缓存时间也很短暂，只在会话（Session）中存在，一旦会话结束就被释放。其具有以下特点：

- 所有的资源都能被推送，但是 Edge 和 Safari 浏览器兼容性不怎么好

- 可以推送 `no-cache` 和 `no-store` 的资源

- 一旦连接被关闭，Push Cache 就被释放

- 多个页面可以使用相同的 HTTP/2 连接，也就是说能使用同样的缓存

- Push Cache 中的缓存只能被使用一次

- 浏览器可以拒绝接受已经存在的资源推送

- 可以给其他域名推送资源

## 协商缓存和强缓存的区别

#### （1）强缓存

 使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。

 强缓存策略可以通过两种方式来设置，分别是 http 头信息中的 Expires 属性和 Cache-Control 属性。

 （1）服务器通过在响应头中添加 Expires 属性，来指定资源的过期时间。在过期时间以内，该资源可以被缓存使用，不必再向服务器发送请求。这个时间是一个绝对时间，它是服务器的时间，因此可能存在这样的问题，就是客户端的时间和服务器端的时间不一致，或者用户可以对客户端时间进行修改的情况，这样就可能会影响缓存命中的结果。

 （2）Expires 是 http1.0 中的方式，因为它的一些缺点，在 HTTP 1.1 中提出了一个新的头部属性就是 Cache-Control 属性，它提供了对资源的缓存的更精确的控制。它有很多不同的值，

 `Cache-Control`可设置的字段：

 

- `public`：设置了该字段值的资源表示可以被任何对象（包括：发送请求的客户端、代理服务器等等）缓存。这个字段值不常用，一般还是使用max-age=来精确控制；

- `private`：设置了该字段值的资源只能被用户浏览器缓存，不允许任何代理服务器缓存。在实际开发当中，对于一些含有用户信息的HTML，通常都要设置这个字段值，避免代理服务器(CDN)缓存；

- `no-cache`：设置了该字段需要先和服务端确认返回的资源是否发生了变化，如果资源未发生变化，则直接使用缓存好的资源；

- `no-store`：设置了该字段表示禁止任何缓存，每次都会向服务端发起新的请求，拉取最新的资源；

- `max-age=`：设置缓存的最大有效期，单位为秒；

- `s-maxage=`：优先级高于max-age=，仅适用于共享缓存(CDN)，优先级高于max-age或者Expires头；

- `max-stale[=]`：设置了该字段表明客户端愿意接收已经过期的资源，但是不能超过给定的时间限制。

 一般来说只需要设置其中一种方式就可以实现强缓存策略，当两种方式一起使用时，Cache-Control 的优先级要高于 Expires。

 **no-cache和no-store很容易混淆：**

 

- no-cache 是指先要和服务器确认是否有资源更新，在进行判断。也就是说没有强缓存，但是会有协商缓存；

- no-store 是指不使用任何缓存，每次请求都直接从服务器获取资源。

 

#### （2）协商缓存

 如果命中强制缓存，我们无需发起新的请求，直接使用缓存内容，如果没有命中强制缓存，如果设置了协商缓存，这个时候协商缓存就会发挥作用了。

 上面已经说到了，命中协商缓存的条件有两个：

 

- `max-age=xxx` 过期了

- 值为`no-store`

 使用协商缓存策略时，会先向服务器发送一个请求，如果资源没有发生修改，则返回一个 304 状态，让浏览器使用本地的缓存副本。如果资源发生了修改，则返回修改后的资源。

 协商缓存也可以通过两种方式来设置，分别是 http 头信息中的**Etag** 和**Last-Modified**属性。

 （1）服务器通过在响应头中添加 Last-Modified 属性来指出资源最后一次修改的时间，当浏览器下一次发起请求时，会在请求头中添加一个 If-Modified-Since 的属性，属性值为上一次资源返回时的 Last-Modified 的值。当请求发送到服务器后服务器会通过这个属性来和资源的最后一次的修改时间来进行比较，以此来判断资源是否做了修改。如果资源没有修改，那么返回 304 状态，让客户端使用本地的缓存。如果资源已经被修改了，则返回修改后的资源。使用这种方法有一个缺点，就是 Last-Modified 标注的最后修改时间只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，那么文件已将改变了但是 Last-Modified 却没有改变，这样会造成缓存命中的不准确。

 （2）因为 Last-Modified 的这种可能发生的不准确性，http 中提供了另外一种方式，那就是 Etag 属性。服务器在返回资源的时候，在头信息中添加了 Etag 属性，这个属性是资源生成的唯一标识符，当资源发生改变的时候，这个值也会发生改变。在下一次资源请求时，浏览器会在请求头中添加一个 If-None-Match 属性，这个属性的值就是上次返回的资源的 Etag 的值。服务接收到请求后会根据这个值来和资源当前的 Etag 的值来进行比较，以此来判断资源是否发生改变，是否需要返回资源。通过这种方式，比 Last-Modified 的方式更加精确。

 当 Last-Modified 和 Etag 属性同时出现的时候，Etag 的优先级更高。使用协商缓存的时候，服务器需要考虑负载平衡的问题，因此多个服务器上资源的 Last-Modified 应该保持一致，因为每个服务器上 Etag 的值都不一样，因此在考虑负载平衡时，最好不要设置 Etag 属性。

 **总结：**

 强缓存策略和协商缓存策略在缓存命中时都会直接使用本地的缓存副本，区别只在于协商缓存会向服务器发送一次请求。它们缓存不命中时，都会向服务器发送请求来获取资源。在实际的缓存机制中，强缓存策略和协商缓存策略是一起合作使用的。浏览器首先会根据请求的信息判断，强缓存是否命中，如果命中则直接使用资源。如果不命中则根据头信息向服务器发起请求，使用协商缓存，如果协商缓存命中的话，则服务器不返回资源，浏览器直接使用本地资源的副本，如果协商缓存不命中，则浏览器返回最新的资源给浏览器。

## 对浏览器内核的理解

浏览器内核主要分成两部分：

- 渲染引擎的职责就是渲染，即在浏览器窗口中显示所请求的内容。默认情况下，渲染引擎可以显示 html、xml 文档及图片，它也可以借助插件显示其他类型数据，例如使用 PDF 阅读器插件，可以显示 PDF 格式。

- JS 引擎：解析和执行 javascript 来实现网页的动态效果。

 最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。

![浏览器进程4](/Users/guohaohao/Documents/github/fe-growth-path/imgs/性能优化/浏览器进程4.png)

## 宏任务和微任务分别有哪些

- 微任务包括： promise 的回调、node 中的 process.nextTick 、对 Dom 变化监听的 MutationObserver。
- 宏任务包括： script 脚本的执行、setTimeout ，setInterval ，setImmediate 一类的定时事件，还有如 I/O 操作、UI 渲染等。

## V8的垃圾回收机制是怎样的

V8 实现了准确式 GC，GC 算法采用了分代式垃圾回收机制。因此，V8 将内存（堆）分为新生代和老生代两部分。

**（1）新生代算法**

 新生代中的对象一般存活时间较短，使用 Scavenge GC 算法。

在新生代空间中，内存空间分为两部分，分别为 From 空间和 To 空间。在这两个空间中，必定有一个空间是使用的，另一个空间是空闲的。新分配的对象会被放入 From 空间中，当 From 空间被占满时，新生代 GC 就会启动了。算法会检查 From 空间中存活的对象并复制到 To 空间中，如果有失活的对象就会销毁。当复制完成后将 From 空间和 To 空间互换，这样 GC 就结束了。

> 具体描述：新生代from空间采用根搜索算法，基本思路就是通过一系列名为”GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。如果对象是可用的，将该对象复制到to空间，（起初是用深度优先的方式，后来为了内存问题以及抢占线程问题，改成了广度优先的方式，再后来变成了优先级的方式（类似于react fiber），OK后，清除from空间所有，将from和to空间调换。当走完一次后，to空间的对象会标记已经进行过新生代的次数，如果多次后仍然在新生代中，就将该对象放在老生代处理（或者对象过大，也会直接放到老生代处理）。）

**（2）老生代算法** 

 老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是标记清除算法和标记压缩算法。

 先来说下什么情况下对象会出现在老生代空间中：

- 新生代中的对象是否已经经历过一次 Scavenge 算法，如果经历过的话，会将对象从新生代空间移到老生代空间中。

- To 空间的对象占比大小超过 25 %。在这种情况下，为了不影响到内存分配，会将对象从新生代空间移到老生代空间中。

老生代中的空间很复杂，有如下几个空间

```C%2B%2B
enum AllocationSpace { 

    // TODO(v8:7464): Actually map this space's memory as read-only. 

    RO_SPACE, // 不变的对象空间 

    NEW_SPACE, // 新生代用于 GC 复制算法的空间 

    OLD_SPACE, // 老生代常驻对象空间 

    CODE_SPACE, // 老生代代码对象空间 

    MAP_SPACE, // 老生代 map 对象 

    LO_SPACE, // 老生代大空间对象 

    NEW_LO_SPACE, // 新生代大空间对象 

    FIRST_SPACE = RO_SPACE, 

    LAST_SPACE = NEW_LO_SPACE, 

    FIRST_GROWABLE_PAGED_SPACE = OLD_SPACE, 

    LAST_GROWABLE_PAGED_SPACE = MAP_SPACE 

};
```

在老生代中，以下情况会先启动标记清除算法：

- 某一个空间没有分块的时候

- 空间中被对象超过一定限制

- 空间不能保证新生代中的对象移动到老生代中

 在这个阶段中，会遍历堆中所有的对象，然后标记活的对象，在标记完成后，销毁所有没有被标记的对象。在标记大型对内存时，可能需要几百毫秒才能完成一次标记。这就会导致一些性能上的问题。为了解决这个问题，2011 年，V8 从 stop-the-world 标记切换到增量标志。在增量标记期间，GC 将标记工作分解为更小的模块，可以让 JS 应用逻辑在模块间隙执行一会，从而不至于让应用出现停顿情况。但在 2018 年，GC 技术又有了一个重大突破，这项技术名为并发标记。该技术可以让 GC 扫描和标记对象时，同时允许 JS 运行。

 清除对象后会造成堆内存出现碎片的情况，当碎片超过一定限制后会启动压缩算法。在压缩过程中，将活的对象向一端移动，直到所有对象都移动完成然后清理掉不需要的内存。

**详细叙述**

概念：

引用：内存的起始地址

弱引用：WeakMap，WeakSet

垃圾：无任何引用的对象

回收：清空垃圾占用的内存

垃圾回收区域：堆内存

发生时间：程序空闲时

垃圾回收机制主要回收堆内存，栈内存有自己的一套回收方式

一个栈空间的情况大致如下

![浏览器进程5](/Users/guohaohao/Documents/github/fe-growth-path/imgs/性能优化/浏览器进程5.png)

## 哪些操作会造成内存泄漏？

第一种情况是由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。

 第二种情况是设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。

 第三种情况是获取一个 DOM 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。

 第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。

# 浏览器缓存

## 简介

浏览器缓存主要分为四个阶段：

1. `强制缓存阶段`：先在本地查找该资源，如果有发现该资源，而且该资源还没有过期，就使用这一个资源，完全不会发送 http 请求到服务器。
2. `协商缓存阶段`：让客户端与服务器之间能实现缓存文件是否更新的验证、提升缓存的复用率。如果在本地缓存找到对应的资源，但是不知道该资源是否过期或者已经过期，则发一个 http 请求到服务器，然后服务器判断这个请求，如果请求的资源在服务器上没有改动过，则返回 304，让浏览器使用本地找到的那个资源。
3. `启发式缓存阶段`：当缓存过期时间的字段一个都没有的时候，浏览器下次并不会直接进入协商阶段，而是先进入启发式缓存阶段，它根据响应头中2个时间：Date和Last-Modified 之间的时间差值，取其值的 10%作为缓存时间周期。也就是说， 当存有 Last-Modfied 字段的时候，即使是断网，且强缓存都失效后，也有一定时间是直接读取缓存文件的。etag 是没有这个阶段的。

4. `缓存失败阶段`：当服务器发现请求的资源已经修改过，或者这是一个新的请求(再本来没有找到资源)，服务器则返回该资源的数据，并且返回200，当然这个是指
   找到资源的情况下，如果服务器上没有这个资源，则返回 404。

HTTP缓存都是从第二次请求开始的：

1. 第一次请求资源时，服务器返回资源，并在`response header`中回传资源的缓存策略；

2. 第二次请求时，浏览器判断这些请求参数，击中强缓存就直接200，否则就把请求参数加到`request header`头中传给服务器，看是否击中协商缓存，击中则返回304，否则服务器会返回新的资源。这是缓存运作的一个整体流程图：

   ![qid-8-1](/Users/guohaohao/Documents/github/fe-growth-path/imgs/性能优化/qid-8-1.png)

## 一、强缓存

> 强缓存一般存放于 Memory Cache 或者 Disk Cache。

强缓存通过 Expires 和 Cache-Control 两个响应头实现

### 1.1 Expires

Expires 是 http1.0提出的一个表示资源过期时间的 header，它描述的是一个绝对时间，由服务器返回。
Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效。
如：

> Expires: Wed Oct 21 2020 10:58:44 GMT

####  优势特点

* HTTP1.0的产物，可以在HTTP1.0和HTTP1.1中使用，简单易用
* 以时刻标识失效时间

#### 劣势问题

* 时间时有服务器发送的UTC，如果服务器时间和客户时间存在不一致，可能会出现问题
* 存在版本问题，到期之前你的修改客户是端不可知的

### 1.2 Cache -Control

Cache-Control 出现于 HTTP/1.1 优先级高于 Expires 表示的是相对时间

#### 缓存请求指令：

* `max-age=<seconds>`表示缓存内容将在 seconds 秒后失效
* `max-stale<=seconds>`客户端愿意接收一个已经过期了的响应。如果指定了 max-stale 的值，则最大容忍时间为对应的秒数。如果没有指定，那么说明浏览器愿意接收任何 age 的响应（age 表示响应由源站生成或确认的时间与当前时间的差值）
* `min-fresh=<seconds>`能够容忍的最小新鲜度。`min-fresh`标示了客户端不愿意接受新鲜度不多于当前的 age 加上 `min-fresh `设定的时间之和的响应
* `no-cache` 客户端缓存内容，是否使用缓存则需要经过协商缓存来验证决定.
* `no-store `所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存

#### 缓存响应指令： 

* `no-cache`
* `no-transform` 中间代理有时会改变图片以及文件的格式，从而达到提高性能的效果。no-transform 指令告诉中间代理不要改变资源的格式
* `public `所有内容都将被缓存（客户端和代理服务器都可缓存）
* `private` 所有内容只有客户端可以缓存，Cache-Control 的默认取值
* `max-age=<seconds>`
* `s-maxage=<seconds>`与` max-age` 类似

#### 优势特点

* HTTP1.1的产物，以时间间隔标识失效时间，解决了Expires服务器和客户端相对时间的问题
* 比Expires配置更丰富

#### 劣势问题

* 存在版本问题，到期之前的修改客户端是不可知的

## 二、协商缓存

当浏览器对资源的请求没有命中强缓存，就会发一个请求到服务器当中，去验证是否命中协商缓存，请求先攻返回的 http 状态为 304 响应字符串为` Not Modified` 而协商缓存时利用的是：`Last-Modified`,` If-Modified-Since`，`Etag`,` If-None-Match`。

### 2.1 Last-Modified、 If-Modified-Since

`last-Modified` 表示一个资源的最后更新时间，当需要进行协商缓存的时候，客户端会在请求头上加上` If-Modified-since `去询问在当前日期之后资源是否有更新，有的话，就需要将新的资源发送回来（200）有一种情况，如果在本地打开了缓存的文件，就会造成` Last-Modified` 被改了，为了解决这个问题，所以在 HTTE/1.1 增加了 `Etag`。

#### 优势特点

* 不存在版本问题，每次请求都会去服务器进行校验。服务器对比最后修改时间如果相同则返回304，不同返回200以及资源内容。

#### 劣势问题

* 只要资源修改，无论內容是否发生实质性的变化，都会将该资源返回客户端。例如周期性重写，这种情况下该资源包含的数据实际上一样的。
* 以时刻作为标识，无法识别一秒内进行多次修改的情况。如果资源更新的速度是秒以下单位，那么该缓存是不能被使用的，因为它的时间单位最低是秒。
* 某些服务器不能精确的得到文件的最后修改时间。
* 如果文件是通过服务器动态生成的，那么该方法的更新时间永远是生成的时间，尽管文件可能没有变化，所以起不到缓存的作用。

### 2.2 Etag,If-None-Match

`Etag `就像一个指纹，资源变化都会导致 比`Etag `变化，`Etag` 可以保证资源都是最新的。同样的，当命中了协商缓存，客户端就会发送上一次返回的 `Etag` 给服务器去询问当前资源是否更新，就需要发送新的资源。

1. `Etag `得优先级要高于` Last-Modified`

2. 一些文件会因为仅仅是修改时间发生了改变，而重新去获取资源，而使用 ETag
3. 文件修改频率非常频繁，如在秒级以下得改变，由于` If-Modified-Since `能检查到得最小是秒级得，这种改变` Last-Modified `就无法判断到进行了修改
4. 无法知道具体修改时间的服务器

etag 可以通过文件的` Last-Modified `和` content-length `计算。
Nginx官方默认的ETag计算方式是为"文件最后修改时间16进制-文件长度16进制"。例：`ETag: “59e72c84-2404”`

#### 优势特点

* 可以更加精确的判断资源是否被修改，可以识别一秒内多次修改的情况。
* 不存在版本问题，每次请求都回去服务器进行校验。

#### 劣势问题

* 计算ETag值需要性能损耗。
* 分布式服务器存储的情况下，计算ETag的算法如果不一样，会导致浏览器从一台服务器上获得页面内容后到另外一台服务器上进行验证时现ETa9不匹配的情况。

> 注意：
> 不管怎么样的算法，在服务器端都要进行计算，计算就有开销，会带来性能损失。因此为了榨干这一点点性能，不少网站完全把Etag禁用了(比如Yahool)，这其实不符合HTTP/1.1的规定，因为HTTP/11总是鼓励服务器尽可能的开启Etag。

## 三、总结

强制缓存优先于协商缓存进行，若强制缓存(`Expires` 和 `Cache-Control`)生效则直接使用缓存，若不生效则进行协商缓存(`Last-Modified / If-Modified-Since` 和` Etag / If-None-Match`)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回 200，重新返回资源和缓存标识，再存入浏览器缓存中；生效则返回 304，继续使用缓存。

1. 对于频繁变动的资源，首先需要使用` Cache-Control:no-cache `使浏览器每次都请求服务器，然后配合 ETag 或者` Last-Modified` 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。
2. 处理不常变化的资源时，给它们的` Cache-Control `配置一个很大的` max-age=31536000`(一年)，这样浏览器之后请求相同的 URL 会命中强制缓存。而为了解决更新的问题，就需要在文件名(或者路径)中添加 hash，版本号等动态字符，之后更改动态字符，从而达到更改引用 URL 的目的，让之前的强制缓存失效（其实并未立即失效，只是不再使用了而己)。在线提供的类库（如jquery-3.3.1.min.js，lodash.min.js等）均采用这个模式。

# 其他缓存

>  memcache、 redis、 squid、 varnish、 web cache、 CDN 等等都是缓存相关的。

## 一、数据库缓存

我们知道常见的数据库，比如 oracle、mysql 等，数据都是存放在磁盘中。虽然在数据库层也做了对应的缓存，但这种数据库层次的缓存一般针对的是查询內容，而且粒度也太小，一般只有表中数据没有变更的时候，数据库对应的 cache 才发挥了作用。但这并不能减少业务系统对数据库产生的增、删、查、改的庞大 10 压力。所以数据库缓存技术在此诞生，实现热点数据的高速缓存，提高应用的响应速度，极大缓解后端数据库的压力。

## 二、静态缓存

静态缓存技术，CDN 是经典代表之作。静态缓存技术面非常广，涉及的开源技术包含 apache、 Lighttpd、 nginx、 varnish、 squid 等。
静态缓存，一般指 web 类应用中，将图片、js、css、视频、html 等静态文件/资源通过磁盘/内存等缓存方式，提高资源响应方式，减少服务器压力/资源开销的一门缓存技术。
静态缓存又可以简单的分类，有浏览器缓存、磁盘缓存、内存缓存、nginx 的内存缓存、CDN 等等。

### 2.1 浏览器缓存

浏览器缓存，也称为客户端缓存，是静态缓存中最常见最直接的表现形式，很多时候都往往被人忽略掉。
比如 nginx 配置中 可以配置

```nginx
location ~ .*\.(?:jpg|jpeg|gif|png|ico|cur|gz|svg|svgz|mp4|ogg|ogv|webm)$
{
    expires      7d;
}

location ~ .*\.(?:js|css)$
{
    expires      7d;
}
```

### 2.2 磁盘缓存

除了存储在客户端的静态缓存(浏览器静态）技术外，在服务器端的静态缓存技术主要分为磁盘缓存和内存缓存两大类。
磁盘缓存顾名思义就是存储到了磁盘上。
内存缓存就是把静态文件缓存在服务器端的内存中。所以这种缓存，如若命中缓存的话，取内存中的缓存数据返回比取磁盘中的缓存数据返回，性能要高很多。

### 2.3 CDN

它是静态缓存加速最典型的代表。CDN 技术并不是一门新的技术，它是基于传统 nginx、squid、 varnish 等 web 缓存技术，结合 DNS 智能解析的静态缓存加速技术。值得注意的是，他对动态链接访问并没有加速效果。

简单地说，CDN是一个经策略性部署的整体系统，包括分布式存储、负载均衡、网络请求的重定向和内容管理4个要件，而内容管理和全局的网络流量管理(Traffic Management)是CDN的核心所在。
通过用户就近性和服务器负载的判断，CDN确保内容以一种极为高效的方式为用户的请求提供服务。

CDN 的静态缓存技术核心主要在于两点：

1. `节点缓行`：对需要加速的网的应用，相应的静态资源通过内存缓存+磁盘缓存的方式缓存在服务器端。
2. `精准调度`：对访问的用户 ip 进行智能解析调度，实现就近缓存节点访问。比如北京用户访问 `www.a.com` 。通过 dns 解析的时候，分析用户 ip，发现是北京用户。则 dns 返回对应北京缓存节点的ip 地址给到用户，则用户 `www.a.com` 默认访问北京服务器上面存数据，实现就近访问的策略，大大提升了访问速度。

#### 完整流程

1. 客户端向服务器请求一个静态资源，如请求cdn服务器的query文件， `http://code jquery.com/jquery-migrate-1.2.1.min-js`，首先会进行dns域名解析，但这里解析出来不是直接返回源站ip，而是解析到一个智能dns服务器。
2. 这个智能dns服务器会将离用户最近的cdn服务器的ip返回给客户端。
3. 客户端向cdn服务器获取jquery文件，如果改服务器有这个静态资源并且未过期，这个jquery文件将直接返回给客户端 
4. 如果cdn服务器有该静态资源，但已过期，会向源站询问是否更改，未变更则直接返回该文件并延长有效期，如果源站文件变更，重新从源站获取并缓存到自己的cnd服务器。
5. 源站也可以主动更新cdn网络下的静态资源以确保客户端最快的获取到最新的资源。

![cdn2](/Users/guohaohao/Documents/github/fe-growth-path/imgs/性能优化/cdn2.png)

#### 原理

在描述CDN的实现原理之前，让我们先看传统的未加缓存服务的访问过程，以便了解CDN缓存访问方式与末加缓存访问方式的差别：
用户提交域名一浏览器对域名进行解释一得到目的主机的P地址一根据1P地址访问发出请求一得到请求数据并回复
由上可见，用户访问未使用CDN缓存网站的过程为：

1. 用户向浏览器提供要访问的域名；
2. 浏览器调用域名解析函数库对域名进行解析，以得到此域名对应的P地址；
3. 浏览器使用所得到的/P地址，向域名的服务主机发出数据访问请求;
4. 浏览器根据域名主机返回的数据显示网页的内容。

通过以上四个步骤，浏览器完成从用户处接收用户要访问的域名到从域名服务主机处获取数据的整个过程。
CDN网络是在 用户和服务器之问增加Cache层，如何将用户的请求引导到Cache 上获得源服务器的数据，主要是通过接管DNS实现，下面让我们看看访问使用CDN缓 存后的网站的过程：

![cdn](/Users/guohaohao/Documents/github/fe-growth-path/imgs/性能优化/cdn.png)

#### 优化机制

1. 资源调度：CDN会根据用户接入网络的ip寻找距离用户最优路径的服务器。调度的方式主要有DNS调度、http 302调度、使用 HTTP 进行的 DNS 调度 (多用于移动端）；
2. 缓存策略和数据检索：CDN服务器使用高效的算法和数据结构，快速的检索资源和更新读取缓存；
   * 网络优化：从OS七层模型进行优化，达到网络优化的目的。
   * L1物理层：硬件设备升级提高速度
   * L2数据链路层：寻找更快的网络节点、确保 Lastmile 尽量短
   * L3路由层：路径优化，寻找两点间最优路径
   * L4传输层：协议TCP优化，保持长连接、TCP快速打开
   * L7应用层：静态资源压缩、请求合并

## 三、前端常用缓存技术

### 3.1 Http 缓存

当客户端第一次完成数据请求后，浏览器会缓存本次请求的数据，当下次执行相同请求，则直接在缓存数据库中返回；但 HTTP 缓存有多种规则，根据是否向服务器发送请求分为“强缓存”和“协商缓存”两种。
两者的主要区别是使用本地缓存的时候，是否需要向服务器验证本地缓存是否依旧有效。顾名思义，协商缓存，就是需要和服务器进行协商，最终确定是否使用本地缓存。

#### 最佳实践

缓存的意义就在于减少请求，更多地使用本地的资源，给用户更好的体验的同时，也减轻服务器压力。所以，最佳实践，就应该是尽可能命中强缓存，同时，能在更新版本的时候让客户端的缓存失效。
在更新版本之后，如何让用户第一时间使用最新的资源文件呢？机智的前端们想出了一个方法，在更新版本的时候，顺便把静态资源的路径改了，这样，就相当于第一次访问这些资源，就不会存在缓存的问题了。
现在我们在使用 webpack 打包的时候，可以在文件名上带上 hash 值。
所以，可以得出一个比较合理的缓存方案
HTML：使用协商缓存。
CSS&JS&图片：使用强缓存，文件命名带上 hash 值。

#### 配置方式

###### 强缓

```js
res.setHeader("Cache-Control", "public, max-age=xxx");
```

###### 协商缓存

```js
res.setHeader("Cache-Control", "public, max-age=0");
res.setHeader("Last-Modified", xxx);
res.setHeader("ETag", xxx);
```

### 3.2 Service Worker 离线缓存

`Service Worker` 能够充当网络代理服务器的功能，能拦截网络请求 (fetch）、离线缓存

* `Service Worker` 是运行在 worker 上下文，所以不能访问 DOM
* 运行在其他线程中，不会造成拥堵，完全异步，因此同步 API 不可使用
* 只能在 https 或本地 localhost 上运行

#### 使用

###### 注册 service Worker

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>serviceWorker</title>
    <script type="text/javascript">
      if ("serviceWorker" in navigator) {
        navigator.serviceWorker
          .register("./serviceWorker.js", { scope: "./" })
          .then((registration) => {
            console.log("注册成功", registration.scope);
          })
          .catch((err) => {
            console.log("注册失败", err);
          });
      }
    </script>
  </head>
  <body></body>
</html>
```

###### ServerWorker.js

```js
let self = this;
// 完成serviceWorker的注册与缓存文件
self.addEventListener("install", function (event) {
  event.waitUntil(
    caches.open("v1").then(function (cache) {
      return cache.addAll([
        "./index.html", //缓存文件
      ]);
    })
  );
});

// 监听拦截http请求，做资源缓存
self.addEventListener("fetch", function (event) {
  event.responseWith(
    // 在缓存中匹配请求
    caches.match(event.request).then(function (response) {
      // 若缓存存在，则直接返回
      if (response) {
        return response;
      }
      // 拷贝request副本
      let fetchRequest = event.request.clone();
      // 未命中缓存，发起网络请求
      return fetch(fetchRequest).then(function (response) {
        // 判断是否请求成功
        if (!response || response.status != 200 || response.type != "basic") {
          return response;
        }
        // 缓存请求和响应数据
        let fetchResponse = response.clone();
        caches.open("v1").then(function (cache) {
          cache.put(event.request, fetchResponse);
        });
        // 返回真实的网络请求数据
        return response;
      });
    })
  );
});
```

### 3.3 mainfest

html5 引入的新标准，可以离线缓存静态文件

#### 优点：

* 离线浏览
* 已缓存资源加载速度更快
* 减轻服务器负载 - 只需从服务器中获取更新或修改过的资源

#### 使用

新建一个后缀为`manifest.appcache `的文件，文件内容如下

```
CACHE MANIFEST // 首次完成请求后进行缓存，离线可访问
manifest.css

NETWORK: // 每次请求都需要网络，不缓存
network.css

FALLBACK: // 页面无法连接网络时显示的页面
404.html
```

- 在中加入 manifest 属性并指定文件所在地址

```html
<html manifest="manifest.appcache">
```

# PWA

## 简介

PWA (Progressive web apps，渐进式 Web 应用）运用现代的 Web API 以及传统的渐进式增强策略来创建跨平台 Web 应用程序。

### 什么是PWA应用？

PWA应用是指那些使用指定技术和标准模式来开发的web应用，这将同时赋予它们web应用和原生应用的特性。
举例：PWA既能像网站那么快捷，又能像QQ、微信一样离线在本地运行

### 什么使应用成为PWA

**总体依据**：当应用程序满足某些要求时，可以将其视为PWA，或者实现一组给定的功能：离线工作，可安装，易于同步，可以发送推送通知等。
**辨别工具：**还有一些工具可以按百分比衡量应用的完整性。(Lighthouse目前是最受欢迎的工具）通过实施各种技术优势，我们可以使应用程序更加渐进式，从而最终获得更高的Lighthouse 得分。但这只是一个粗略的指标。
**辨别原则：**这里有一些关键的原则来辨别一个web应用是否是一个PWA应用。它应该具有以下特点：

* `Discoverable`，内容可以通过搜索引擎发现。
* `Installable`， 可以出现在设备的主屏幕。
* `Linkable`， 你可以简单地通过一个URL来分享它。
* `Network independent`，它可以在离线状态或者是在网速很差的情况下运行。
* `Progressive`，它在老版本的浏览器仍旧可以使用，在新版本的浏览器上可以使用全部功能。
* `Re-engageable`，无论何时有新的内容它都可以发送通知。
* `Responsive`，它在任何具有屏幕和浏览器的设备上可以正常使用—包括手机，平板电脑，笔记本，电视，冰箱，等。
* `Safe`，在你和应用之间的连接是安全的，可以阻止第三方访问你的敏感数据。

### PWA优势

我们需要在设计网站时时刻记住PWA的优势。app shell允许网站：

* 可访问：即使看起来像个本地应用，请记住它仍然是个网站——你可以点击页面中的连接并分享给你的朋友。
* 渐进式：先从“好用的，旧式的网站”出发，一步步渐进式的增加新特性，记住要随时侦测浏览器是否可用这些新增加的特性，同时注意处理任何由于浏览器不支持而导致的error。例如，`service workers`可以让离线工作成为可能，同时提高网站的体验，但是记住就算没有`service worker`网站也应该能运行良好。
* 响应式：响应式页面设计也适用于渐进式web应用，主要是针对移动端设备。有许多不同的设备配置有浏览器——你需要让网站支持不同的屏幕尺寸，视窗 (`view port`）或者是不同的像素密度(`pixel density`)，常用的技术有`viewport meta tag`, `CSS media queries`, `Flexbox`。

### PWA存在的问题

1. 支持率不高;现在ios手机端不支持pwa，IE也暂时不支持
2. Chrome在中国桌面版占有率还是不错的，安卓移动端上的占有率却很低
3. 各大厂商还未明确支持pwa
4. 依赖的GCM服务在国内无法使用
5. 微信小程序的竞争

## 关键技术

1. Manifest
2. Server Worker

### Manifest实现添加至主屏幕

#### Index.html

```html
<head>
  <title>Minimal PWA</title>
  <meta name="viewport" content="width=device-width, user-scalable=no" />
  <link rel="manifest" href="manifest.json" />
  <link rel="stylesheet" type="text/css" href="main.css">
  <link rel="icon" href="/e.png" type="image/png" />
</head>
```

#### Manifest.json

```json
{
  "name": "Minimal PWA", // 必填 显示的插件名称
  "short_name": "PWA Demo", // 可选  在APP launcher和新的tab页显示，如果没有设置，则使用name
  "description": "The app that helps you understand PWA", //用于描述应用
  "display": "standalone", // 定义开发人员对Web应用程序的首选显示模式。standalone模式会有单独的
  "start_url": "/", // 应用启动时的url
  "theme_color": "#313131", // 桌面图标的背景色
  "background_color": "#313131", // 为web应用程序预定义的背景颜色。在启动web应用程序和加载应用程序的内容之间创建了一个平滑的过渡。
  "icons": [ // 桌面图标，是一个数组
    {
    "src": "icon/lowres.webp",
    "sizes": "48x48",  // 以空格分隔的图片尺寸
    "type": "image/webp"  // 帮助userAgent快速排除不支持的类型
  },
  {
    "src": "icon/lowres",
    "sizes": "48x48"
  },
  {
    "src": "icon/hd_hi.ico",
    "sizes": "72x72 96x96 128x128 256x256"
  },
  {
    "src": "icon/hd_hi.svg",
    "sizes": "72x72"
  }
  ]
}
```

### service worker实现离线缓存

Service Worker 是 Chrome 团队提出和力推的一个 WEB API，用于给 web 应用提供高级的可持续的后台处理能力。
Service Workers 就像介于服务器和网页之间的拦截器，能够拦截进出的HTTP 请求，从而完全控制你的网站。

#### 最主要的特点

1. 在页面中注册并安装成功后，运行于浏览器后台，不受页面刷新的影响，可以监听和截拦作用域范围内所有页面的 HTTP 请求。
2. 网站必须使用 HTTPS。除了使用本地开发环境调试时(如域名使用 localhost)
3. 运行于浏览器后台，可以控制打开的作用域范围下所有的页面请求
4. 单独的作用域范围，单独的运行环境和执行线程
5. 不能操作页面 DOM。但可以通过事件机制来处理
6. 事件驱动型服务线程