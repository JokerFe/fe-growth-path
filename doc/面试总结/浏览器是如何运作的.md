## 浏览器是如何运作的

浏览器可以简单分为三块：**用户界面**、**浏览器引擎**、**渲染引擎**。

**用户界面**用于展示除标签页窗口之外的其他用户界面内容。**渲染引擎**负责渲染用户请求的页面。在用户界面和渲染引擎之间有一个**浏览器引擎**，用于在用户界面和渲染引擎之间传递数据。

渲染器下面还有很多小的功能模块，比如：负责网络请求的网络模块、用于解析和执行js的js解释器、还有数据存储持久层帮助浏览器存储各种数据（eg:cookie）。

渲染引擎可以说是一个浏览器的核心与灵魂。我们往往会把渲染引擎叫做浏览器的内核，不同浏览器使用的内核也不太一样。其中IE使用的是Trident、Firefox使用的Gecko、Safari使用的是Webkit并将其开源、Chrome是使用的基于webkit改造优化的Blink渲染引擎也将其开源、Opera和Edge使用的是Blink。可以看到Webkit项目的开源对浏览器的发展做了多大的贡献。

浏览器是运行在操作系统上的一个应用程序，每个应用程序必须至少启动一个进程来执行其功能，每个程序往往需要运行很多任务，进程就会创建一些线程来帮助它去执行这些小的任务。

>  **进程**是操作系统进行资源分配和调度的基本单元，可以申请和拥有计算机资源，进程是程序的基本执行实体。
>
>  **线程**是操作系统能够进行运算调度的最小单位，一个进程中可以并发多个线程，每条线程并行执行不同的任务。

当我们启动某个程序时就会创建一个进程来执行任务代码，同时会为该进程分配内存空间，该应用程序的状态都保存在该内存空间里。当应用关闭时，该内存空间就会被回收。进程可以启动更多的进程来执行任务，由于每个进程分配的内存空间是独立的，如果两个进程间需要传递某些数据，则需要进程间通讯管道IPC来传递。很多应用程序都是多进程的结构，这样是为了避免某一个进程卡死，由于进程间的相互独立，这样就不会影响到整个应用程序。进程可以将任务分成更多细小的任务，然后通过创建多线程并行执行不同的任务。同一进程下的线程之间是可以直接通信共享数据的。

早期的浏览器并不是多进程的结构，而是一个单进程的结构，一个进程中大概有页面线程负责页面渲染和展示等，js线程执行js代码，还有其它各种线程。单进程的结构引发了很多问题：一是**不稳定**，其中一个线程的卡死可能会导致整个进程出问题，比如打开多个标签页，其中一个标签卡死可能会导致整个浏览器无法正常运行；二是**不安全**，浏览器之间是可以共享数据的，那js线程岂不是可以随意访问浏览器进程内的所有数据；三是**不流畅**，一个线程需要负责太多事情会导致运行效率的问题。所以为了解决以上这些问题，现在采用了多进程浏览器结构。根据不同进程功能来拆卸浏览器，我们可以将它分解为这样的结构：其中**浏览器进程**负责控制Chrome浏览器出标签页外的用户界面，包括地址栏、书签、后退和前进按钮，以及负责与浏览器的其他进程协调工作；**网络进程**负责发起接受网络请求；**GPU进程**负责整个浏览器界面的渲染；插件进程负责控制网站使用的所有插件，例如flash，这里的插件指的不是chrome应用市场的插件；渲染器进程用来控制显示tab标签内的所有内容，浏览器会在默认情况下为每个标签页创建一个进程（再启动chrome是可以选择进程模型，它有四种进程模型）

当在浏览器地址栏输入网络地址时，浏览器进程的UI线程会捕捉你的输入内容，如果访问的是网址则UI线程会启动一个网络线程来请求DNS进行域名解析，接着开始连接服务器获取数据；如果输入的不是网址而是一串关键词，浏览器就知道你是要搜索，于是就会使用默认配置的渲染引擎来查询。

**浏览器安全验证：**当网络线程获取到数据后会通过SafeBrowsing来检查站点是否是恶意站点，如果是则会提示警告页面，告诉你这个站点有安全问题，浏览器会阻止你的访问，当然也可以强行继续访问。SafeBrowsing是谷歌内部的一套站点安全系统，通过检测该站点的数据来判断是否安全，比如查看该站点的IP是否在谷歌的黑名单之内，当返回数据准备完毕并且安全校验通过时，网络线程会通知UI线程我准备好了。然后UI线程会创建一个渲染器进程Renderer Thread来渲染页面，浏览器进程通过IPC管道将数据传递给渲染器进程，正式进入渲染流程。

**DOM树构建：**渲染器进程接受到的数据也就是HTML。渲染器进程的核心任务就是把html、css、js、image等资源渲染成用户可以交互的web页面。渲染器进程的主线程将html进行解析，构造DOM数据结构。DOM也就是文档对象模型，是浏览器对页面在其内部的表示形式，是web开发程序员可以通过JS与之交互的数据结构和API。html首先通过tokeniser标记化，通过词法分析将输入的html内容解析成多个标记，根据识别后的标记进行DOM树构造，在DOM树构建过程中会创建document对象，然后以document的为根节点的DOM树，不断进行修改，向其中添加各种元素。

**渲染阻塞：**html代码中往往会引入一些额外的资源，比如图片、CSS、JS脚本等，图片和CSS这些资源需要通过网络下载或从缓存中直接加载，这些资源不会阻塞html的解析，因为他们不会影响DOM树的生成，但当HTML解析过程中遇到script标签，就会停止html解析流程，转而去加载解析并且执行JS。这是因为浏览器并不知道JS执行是否会改变当前页面的HTML结构，如果JS代码里用了document.write方法来修改html，之前的和html解析就没有任何意义了，这也就是为什么我们一直说要把script标签要放在合适的位置，或者使用async或defer属性来异步加载执行JS。

**Layout Tree：**在html解析完成后，我们就会获得一个DOM Tree（树），但我们还不知道DOM Tree上的每个节点应该长什么样子，主线程需要解析CSS，并确定每个DOM节点的计算样式，即使你没有提供自定义的CSS样式，浏览器会有自己默认的样式表，比如h2的字体要比h3的大。在知道DOM结构和每个节点的样式后，我们接下来需要知道每个节点需要放在页面上的哪个位置，也就是节点的坐标以及该节点需要占用多大的区域，这个阶段被称为layout布局，主线程通过遍历dom和计算好的样式来生成Layout Tree。Layout Tree上的每个节点都记录了x、y坐标和边框尺寸。这需要注意的是DOM Tree和Layout Tree并不是一一对应的，设置了display:none的节点不会出现在Layout Tree上，而在before伪类中添加了content值的元素content中的内容会出现在Layout Tree上，不会出现在DOM树里，这是因为DOM是通过HTML解析获得的，并不关系样式，而Layout Tree是根据DOM和计算好的样式来生成，Layout Tree是和最后展示在屏幕上节点是对应的。

**绘制（paint）：**现在我们已经知道了元素的大小形状和位置，但还不知道以什么样的顺序绘制（paint）这个节点，例如z-index这个属性会影响节点绘制的层级关系，如果按照dom的层级结构来绘制页面则会导致错误的渲染。所以为了保证在屏幕上展示正确的层级，主线程遍历Layout Tree创建一个绘制记录表（Paint Record），该表记录了绘制的顺序，这个阶段配称为绘制（Paint）。

**栅格化：**现在知道了文档的绘制顺序，终于到了该把这些信息转化成像素点显示在屏幕上了，这个行为被称为栅格化（Rastering）。chrome最早使用了一种很简单的方式，只栅格化用户可视区域的内容，当用户滚动页面时，再栅格化更多的内容来填充缺失的部分，这种方式带来的问题就是会导致展示延迟。现在chrome进行了优化升级，使用了一种更为复杂的栅格化流程叫做合成（compositing），合成是一种将页面各个部分分成多个图层，分别对其进行栅格化，并在合成器线程（compositor Thread）中单独进行合成页面，简单来说就是页面所有的元素按照某种规则进行分图层，并把图层都栅格化好了，然后只需要把可视区的内容组合成一帧展示给用户即可。

**layer tree：**主线程遍历Layout Tree生成layer tree，当Layer Tree生成完毕和绘制顺序确定后，主线程将这些信息传递给合成器线程，合成器线程将每个图层栅格化，由于一层可能想页面的整个长度一样大，因此合成器线程将他们切分为许多图块（tiles），然后将每个图块发送给栅格化线程（Raster Thread），栅格化线程栅格化每个图块，并将他们存储在GPU内存中，当图块栅格化完成后，合成器线程将收集成为 draw quads 的图块信息，这些信息里记录了图块字啊内存中的位置和在页面的那个位置绘制图块的信息，根据这些信息合成器线程生成一个合成器帧（Compositor Frame）然后合成器Frame（帧）通过IPC传递给浏览器进程，接着浏览器进程将合成器帧传送到GPU，然后GPU渲染展示到屏幕上。

当页面发生变化时，比如滚动了当前的页面，都会生成一个新的合成器帧，新的帧再传给GPU，然后再次渲染到屏幕上。

**总结：**浏览器进程中的网络线程请求获取到html数据后，通过IPC将数据传给渲染器进程的主线程，主线程将html解析构造DOM树，然后进行样式计算，根据DOM树和生成好的样式生成Layout Tree，通过遍历Layout Tree生成绘制顺序表，接着遍历Layout Tree生成layer tree，然后主线程将Layer Tree和绘制顺序表一起传给合成器线程，合成器线程按规则进行分图层，并把图层分为更小的图块（tiles）传给栅格化线程进行栅格化，栅格化完成后，合成器线程会获得栅格线程传过来的draw quads图块信息，根据这些信息合成器线程上合成了一个合成器帧，然后将该合成器帧通过IPC传回给浏览器进程，浏览器进程再传递给GPU进行渲染之后就展示到你的屏幕上。

**重绘重排：**当我们改变了一个元素的尺寸位置属性时，会重新进行样式计算（computed style）布局（layout）绘制（paint）以及后面的所有流程，这种行为成为重排。当改变了某个元素的颜色属性时不会重新触发布局，但还是会触发样式计算和绘制这就是重绘，我们可以发现重排和重绘都会占用主线程，还有JS也会运行在主线程，所以就会出现抢占执行时间的问题，如果你写了一个不断导致重排重绘的动画，浏览器则需要在每一帧都运行样式计算布局和绘制的操作。

**优化：**我们知道当前页面以每秒60帧的刷新率时才不会让用户感觉到页面卡顿，如果在运行动画是还有大量的JS任务需要执行，因为布局、绘制和js执行都是在主线程运行的，当在一帧的时间内布局和绘制结束后，还有剩余时间js就会拿到主线程的使用权，如果js执行时间过长，就会导致在下一帧开始时js没有及时归还主线程，导致下一帧动画没有按时渲染，就会出现页面的卡顿。

第一种优化方式：requestAnimationFrame，它会在每一帧被调用，通过回调API的回调，可以把js运行任务分成一些更小的任务块，在每一帧事件用完前暂停js执行归还主线程，这样的话在下一帧开始时，主线程就可以按时执行布局和绘制。  

第二种优化方式：栅格化的整个流程不占用主线程，只在合成器线程和栅格线程中运行，这就意味着它无需和js抢占主线程。如果反复进行重绘和重排可能会导致掉帧，这是因为有可能js执行阻塞了主线程，而CSS中有个动画属性transform，通过该属性实现的动画不会经过布局和绘制，而是直接运行在合成器线程和栅格线程，所以不会受到主线程中js执行的影响。更重要的是听过transform实现的动画由于不需要经过布局绘制样式计算等操作，所以节省了很多运算事件（方便实现负责的动画）

**CPU与GPU**:CPU和GPU作为计算机中最重要的两个计算单元直接决定了计算性能。**CPU**是计算机的大脑，负责处理各种不同的任务。在过去，大多数CPU是单芯片的，核心被安置在同一个芯片上。更新的CPU可以支持多核心，运算能力大大加强。而最新的的cpu已经达到10核心20线程数的能力了。**GPU**是另一个计算机的组成部分，与CPU不同，GPU更擅长利用多核心同时处理单一的任务。像命名那样，GPU最初被用于处理图像。这就是为什么使用GPU可以更快、更顺畅的渲染页面内容。随着GPU的发展，越来越多的计算任务也可以使用GPU来处理。甚至有人说GPU是人工智能的大功臣，可见GPU已经不再仅用于图像处理上了。