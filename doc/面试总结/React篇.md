[toc]

## React各个状态库的优缺点

### Redux

实现了一个发布订阅，组件去监听 store 变化，一旦 store 变化，就会通知组件重新渲染。但是 Redux 不会根据组件使用的状态来定向通知，它会粗暴地通知所有 connect 过的组件。如果在不做浅比较的情况下，整体性能损耗严重。

好处：

1. redux的结构清晰，能hold住更大的项目，它本身和react 无关。
2. 支持typescript , 但是官网描述里面的例子比较少
3. 使用函数式编程 
4. 使用舒服 
5. 原子性低问题 – 不高不低，中等，可能需要使用到中间件来包裹，扩展使用
6. 支持esmodule 

缺点：

1. 数据管理太过中心化，使用起来太过复杂
2. 数据复杂的时候会造成provider的多层嵌套，就像回调地狱一样，同时不同层级如果出现相同的变量，会造成数据的错乱

### Mobx

将状态变成可观察数据，通过数据劫持，拦截其 get 来做依赖收集，知道每个组件依赖哪个状态。在状态的 set 阶段，通知依赖的每个组件重新渲染，做到了精准更新。

优点

1. 简单，剥离了reducer

2. 也是第一个通过proxy观察者模式去实现

3. 也是非常迎合和拥抱react hooks，

4. 它自己库的升级流程从mobx-lite 升级到 mobx-react-lite + mobx-state-tree

缺点

1. 没活下来的原因 它内部使用了yeild generator函数，它在v8的优化中存在很大的性能问题。

2. 它需要使用next next的方式去管控状态，更好的去控制流程
3. 它是个闭包，需要使用@obser()函数的方式去包裹一下组件

### recoil

好处

1. 它是react官方推出的一个自己的原子atom状态管理的库
2. 解决了redux时多层provider的嵌套问题，将所有的状态进行拉平来处理
3. 只需要在app出加一层provider即可

### jotai

1. 日语发音，对标recoil，更加简单。
2. 当时使用redux 或mobx进行项目迁移的时候，需要面临一个很严峻的问题，丢掉原有的代码，重新去换一个状态管理，几乎没有收益
3. 让之前的redux的写法和jotai一样，不需要去掉redux，使用jotai的时候可以继续使用redux，实现无缝衔接的升级
4. 体积非常小，可以实现redux 或mobx和之前一样，融合了万物，市面上的状态管理库，都可以融合到jotai里
5. 它非常依赖hooks
6. Jotai 不需要用 RecoilRoot 或 Provider 等组件包裹，使得结构可以更简洁

### Zustand

1. 它是jotai作者开发的一个比jotai更便捷的状态的管理库
2. 脱离react hooks

### xstate

1. 有限状态机
2. 

1. 1. 简单的基于对象的API来表示状态和它们的转换。
   2. 可以处理复杂的情况，如平行状态
   3. XState Visualizer对于调试和步入状态机真的很不错。
   4. 状态机可以大幅简化复杂的问题。