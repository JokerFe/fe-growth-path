#### 1. 原型链

#### 2. 作用域

作用域分为静态作用域和动态作用域。静态作用域是在定义的时候就确定变量的值。动态作用域是在执行的时候才确定变量的值。js采用的是静态作用域，js作用域也可以叫做词法作用域。是在词法分析阶段处理代码是保证词法作用域不变。js的作用域分为函数作用域和块级作用域。**函数作用域**表示当前函数内的变量和参数能在当前函数内使用和复用，包括它内部嵌套的作用域。**块级作用域**是对最小授权原则进行扩展的工具，将代码从在函数中隐藏信息扩展为块中隐藏。ES5没有标准的块级作用域的概念，它实现的方式有eval、with、try...catch的catch分句、闭包。ES6 通过let和const来实现的。

**作用域链**的是因为作用域的嵌套产生的。它是当前作用域环境与上层环境的一些列变量对象组成的。它保证了当前执行上下文对有权访问的变量的有序访问。在访问变量时首先会在当前作用域内查找，没有就回去上层作用域环境查找...知道找到全局作用域环境。这个由多个执行上下文环境的变量对象构成的链表叫做作用域链。

它的原理与执行上下文有关，原型链就是**[Scope]** ，包含当前执行上下文的AO与父级执行上下文的AO及全局执行上下文的VO。

#### 3. 闭包

从理论上说：那些访问自由变量的函数就是闭包，自由变量是既不是函数的参数也不是函数内部声明的变量。

实际上：即使创建它的执行上下文环境已经销毁，它依然存在。

闭包是在函数执行的时候才会被确定的。它的形成与作用域链的访问顺序有关，只有在内部函数内访问上层作用域环境的变量才会形成闭包。**好处**：立即执行函数、类库封装、隔离作用域、避免全局变量的污染、实现类和继承。**缺点**：内存泄露、this指向、引用的外部变量修改时在内部不生效。**那些是闭包**：回调函数、定时器、事件触发监听函数。**闭包的优化：**回调函数避免使用自由变量、定时器事件监听及时清除。**造成内存泄漏的原因**：闭包、全局变量、dom删除它的监听事件未清除、计时器或回调函数。

#### 4. 浏览器的事件循环机制和Nodejs的事件循环机制

* **浏览器**：

  * **五大线程**：JS引擎线程、事件触发线程、GUI渲染线程、定时处理线程、HTTP异步请求线程。
  * **事件循环**：事件循环机制和 异步事件队列是由事件触发线程维护的。JS引擎会维护一个同步执行栈，同步代码会依次压入栈中，执行结束后出栈。如果遇到异步事件，就会交给对应的线程来执行，执行完后将其回调函数交给事件触发线程，加入到异步事件队列。等同步执行栈空闲时，事件触发线程就会从异步事件队列取出最先加入的回调函数执行，提取规则遵循先入先出。
  * **微任务宏任务**：
    * 微任务：promise 、mutationObserver、process.nextTick 
    * 宏任务：主代码块、setTimeout、setInterval、ajax、ui render、setImmediate

* [**nodeJS**](https://juejin.im/post/5dd24ecce51d453fb903ff37)：

  * node运行过程，application、v8引擎层、nodejs API、libuv层。nodejs的事件循环是由libuv来实现的，它实现了事件循环和文件操作，是nodejs实现异步的核心。

  * **timers**: 一个timer指定一个下限时间而不是一个准确时间



#### 5. this指向

#### 6. 