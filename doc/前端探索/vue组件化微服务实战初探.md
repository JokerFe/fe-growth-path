# Micro-Frontend

> **微前端**是一种类似于微服务的架构，它将微服务的理念应用于浏览器端，即将 Web 应用由单一的单体应用转变为**多个小型前端应用聚合为一的应用**。各个前端应用还可以**独立运行**、**独立开发**、**独立部署**。

## 前言

首先考虑一下下面两个个问题：

1. 什么微前端？为什么微前端在流行？

2. 微前端解决了原有架构下的哪些痛点？

####  什么是微前端

微前端是一种将微服务理念应用于前端的实践方案，它能使一个前端项目由多个团队**独立开发**、**独立运行**以及**独立部署**。它可以将庞大的前端项目抽离成多个微型项目，由不同的团队完成。

微前端开发的几个特性：

* **技术无关**：它允许开发团队自行选择技术栈
* **代码独立**：各个团队交付的功能可以独立使用，避免与其他功能发生耦合
* **样式隔离**：各个交付功能不会污染到其他功能
* **原生支持**：各个交付功能都可以自由使用浏览器原生功能
* **独立部署**：各个交付功能独立部署，有自己的持续交付途径，部署范围小，功能构建快，降低了部署风险。

通过对比微服务来理解微前端：

|          | 微服务                                                       | 微前端                                                       |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 概念     | 一个微服务就是由一组接口构成，接口地址一般是URL。当微服务收到一个请求时，会进行相应的逻辑，输出响应内容。 | 一个微前端则是由一个页面、一个组件构成，更确切的说是一个包含dom、css、js的独立模块。当微前端收到一个模块的请求时，通过路由等匹配，将该模块渲染到页面上。 |
| 实现关键 | 后端微服务会有一个**网关**，作为单一入口接收所有的接口请求，根据URL匹配相应的服务。 | 微前端会有一个加载器，它有一套自己的**模块管理机制**，用来管理这些独立模块，根据加载路径匹配相应的模块进行加载。 |

#### 微前端解决了原有架构下的痛点？

一个新的架构或者一种新的思想的出现，都是为了解决现有项目的一些痛点，那么随着项目开发的不断迭代，会有什么样的问题会让开发者痛不欲生呢？

随着项目的不断迭代，**业务文件越来越多**，**功能模块越来越多**，即使你**组件**封装的再抽象，它依然会越来越多，那么就会导致**定位文件越来越麻烦**（即使文件结构很合理），**每次修改一个小的改动都要进行整个工程项目的打包，况且打包还很慢**。组件封装解决了同一个项目内的功能抽离，但是**跨工程**时却束手无策。

下面借用一张美团技术博客在微前端实践中的一张图：

![](https://p0.meituan.net/travelcube/aba723dd5766a90fca78309da0dc980893221.png)

#### 业务需求

我们的主要业务是车主服务，主要功能是会员服务、购买落地页和支付。而为了更好的为渠道方服务，就需要在购买落地页、 h5页面，所以会有很多的重复的功能和服务，但是有些确实需要跨项目的功能，仅仅依靠组件的封装已经满足不了这些需求，所以需要更多的方式来实现，恰逢公司后端正在进行微服务架构的优化（通过路由注册中心，将更多的后端服务接口通过路由注册中心来派发前端请求），所以前端也借鉴了它的实现方式来优化。

1. 二期重构时，复用部分一期的购买落地页功能和会员权益
2. 会员服务的对外输出
3. 不同项目间组件化的共享
4. 构建车主会员服务中台系统

## 实现微前端的方式

#### 路由分发式微前端

通过路由将不同的业务分发到不同的、独立的前端应用上。通常可以通过HTTP服务器的反向代理来实现，或者通过框架的路由来解决。

这种方式是采用最多、最易采用的方案。但是这种方式更像是多个前端应用的集合，通过一个前端应用将多个应用拼接起来。

简单的就可以通过Nginx的配置，进行反向代理将多个不同的应用或者框架路由页面进行代理。

但是这种方式仅能满足于**共享**整个页面的功能。

#### iframe

> **HTML 内联框架元素** `<iframe>` 表示嵌套的正在浏览的上下文，能有效地将另一个 HTML 页面嵌入到当前页面中。

`iframe`是一种非常古老且普通的技术。它能有效的将一个网页嵌入到另一个页面中，并且两个页面间的`css`和`js`是相互隔离的（除`iframe`间的通信代码），类似于沙箱。在刚入前端时做后台管理系统时，常用到`iframe`。

但是`iframe`还存在很多问题

🍊 **不可控制**： `iframe`嵌入的显示区大小不容易控制，存在一定的局限性

🍊 **bfccache**：URL记录完全失效，页面刷新不能被记忆，刷新会返回首页，`iframe`功能之间跳转也无效

🍊 **兼容性大坑**：`iframe`的样式显示、兼容性等都具有局限性，尤其是在移动端

🍊 **性能开销**：`iframe`阻塞`onload`、占用连接池、多层嵌套页面崩溃等

🍊**SEO**：不支持SEO搜索

#### 微件化

通过一个**新的构建系统**，将部分业务功能组件构建成一个独立的chunk代码，使用时只需远程加载即可。那么重点就是这个新的构建系统，它要提供**一套应用注册机制**，完成功能组件的无缝整合、构建时集成应用和应用**独立发布部署**、一套本地或者远程**加载机制**。

#### 应用组件化

借助于`Web Components`技术，来构建跨框架的前端应用。`Web Components`允许开发者创建可重用的定制元素，并在web应用中使用它们。但是真正在项目中使用`Web Components`技术还不太理想，各大浏览器的兼容程度还不太理想，不过可以借助polyfill来解决。它是一种面向未来演进的架构，当它实现兼容后，`Vue`、`React`、`Angular`框架也就淘汰了。

不论是基于Web Components的Angular，还是Virtual DOM的React，都是因为现有的前端框架都离不开基本的HTML元素DOM。

## 微件化

主要借助`Systemjs`的模块加载机制，通过**`webpack-system-register`**插件提供的新的模块注册机制，脱离`webpack`自带打包`chunk`机制，脱离`chunk`文件的依赖关系和`bundleID`。

##### 下面实现一个简单的demo

**子站项目**：vue组件的代码就不展示了

```js
// webpack.config.js
const VueLoaderPlugin = require('vue-loader/lib/plugin');
const WebpackSystemRegister = require("webpack-system-register");

module.exports = {
    entry: { "index": "./src/index.vue" },
    module: {
        rules: [
            {
                test: /\.vue$/,
                loader: 'vue-loader'
            },
            {
                test: /\.css$/,
                use: [
                    'vue-style-loader',
                    'css-loader'
                ]
            }
        ]
    },
    plugins: [
        new VueLoaderPlugin(),
        new WebpackSystemRegister({})
    ]
}
```

**主站项目**

```html
<div id="app">
  主站
  <hr />
  <index></index>
</div>
<script src="https://cdn.staticfile.org/vue/2.6.11/vue.js"></script>
<script src="https://cdn.staticfile.org/systemjs/6.3.1/s.js"></script>
<script>
  new Vue({
    el: "#app",
    components: {
      "index": () => System.import("http://192.168.199.155:8081/index.js")                								//"index": () => System.import("./src/index.js")
    }
  })
</script>
```

上面这两段代码是简单的实现方式，其实微架构不仅仅是这么简单的。

## 微前端架构设计

### 业务划分

在做之前要考虑清楚，划分微前端的方式是什么。从实际的开发角度考虑主要有以下几种方式：

* 按业务功能划分
* 按权限划分
* 按组织架构划分

##### 1. 业务功能

在一个完整的前端应用中，往往会包含很多业务，这些业务在某种程度上有一定的关联性，但是又不是必须的。就比如在车主服务项目中的相关业务划分为：购买业务、推广业务、纵横金卡业务、纵横黑卡业务、会员服务等，因为项目依托于微信和支付宝平台，有多了一个用户系统。这些业务可以独立为一个系统，彼此之间通过用户ID或Token来关联跳转。这些业务系统的功能模块内部实现**高内聚**，划分起来更轻松。

##### 2. 用户权限

对于一个拥有多角色多权限的前端应用来说，最容易的划分方式就是根据权限来划分服务和应用。就比如之前做过的DWeb牧场生产管理系统、DBI数据分析系统或者智慧高速综合云管理平台系统来说，随着用户权限的增加及应用功能的不断迭代升级，应用会变得越来越臃肿，导致难以维护。那么通过用户的角色权限划分，会更清晰一些。

##### 3. 组织架构

对于后端的微服务来说，根据组织结构拆分服务是很常见的。那么根据不同的团队来划分微前端应用及服务也是一种合理的划分方式。团队之间通过API文档来契约，只要上方都严格按照契约来实现，就可以很轻松的进行协作。同时，这种方案的另一个好处是：不会限制团队的**技术选型**。

对于一个团队来说，内部多个项目时也会根据前两种方式来划分。

### 设计思想

在微前端实现的过程中，以下几点在开发实践中需要关注的内容。

##### 1. 注册中心

微服务的本质可以理解为将服务插件化，简单的说就是将我们平时单应用抽离的模块、组件提升到服务插件级别，有点类似于去中心化的概念。但是，它又不能完全的去中心化，因为它需要一个注册中心：服**务交付方要注册服务地址，使用方通过注册中心调用服务**。

当服务构建或者部署完成后，要向注册中心注册，以便其他有权限的应用访问。这个注册中心可以是一个配置文件、JSON文件、数据库表或者是一个后端服务，它的呈现形式并不一定，它的主要作用就是**控制微前端的加载机制和权限**。

##### 2. 唯一ID

ID的作用是用来表示唯一性。给应用添加**唯一标识符，是为了通过某种特定的规则来区分不同的应用**。在使用的过程中，通过唯一ID来匹配应用，以便准确、高效的找到指定应用。

##### 3. 生命周期

微前端的应用经历的过程大概如下：构建 ☞ 测试 ☞ 部署  ☞  加载  ☞  运行  ☞ 卸载。其中会包含一个应用的更新迭代周期。

##### 4. 高内聚低耦合

在架构设计的过程中，一定要遵循高内聚、低耦合的原则。

* **高内聚**：指的是模块内的关系。**每个模块尽可能的独立完成自己的功能**，不依赖于外部的关系。主要是依赖于**单一职责**和**关注点分离**来实现。

* **低耦合**：指的是模块间的关系。模块与模块之间的接口复杂程度，模块之间联系越复杂耦合度就越高，修改的成本就越大。

在实现开发中要实现这两点其实挺复杂的，要解耦模块间的依赖关系，就需要将数据独立，减少数据的传递。

### 架构设计

当我们想着享受微前端带来的各种便利与好处时，还要考量它存在的风险与技术挑战。以下几点是需要特别关注的内容：

* **样式**
* **共享组件**
* **通信机制**
* **数据管理**

##### 样式

在微前端的实践过程中，一个非常头疼的问题就是：**样式冲突与不匹配**。所以在一个页面里使用多个微前端应用时就需要注意：使用风格一致或者相近的UI设计、避免多个应用间的样式同名冲突或覆盖。其实这样可以通过指定规范即可避免，也可通过打包工具添加chunk值，又或者构建一个沙箱的环境来隔离。

##### 共享组件

在多个应用中使用共享的业务组件和函数，可以通过NPM包的方式或者Git submodule的方式来引入。当然在进行版本迭代更新的时候，要注意兼容问题，确定所有引用的应用的完整性。

##### 通信机制

还有一个让人头疼的问题就是微应用间的通信机制。在微前端的架构中，应用关系间的关系主要有两种：**父子通信**、**同级通信**。

* **父子通信**

* **同级通信**

##### 数据管理

这里的数据管理指的是应用中用户或者业务的状态及处理。在通常的单页面应用中一般是由cookie或者session来维持的。在微前端的应用中一般使用的方式为：

* URL传参
* 通过H5的本地存储方式：LocalStorage、IndexedDB、WebSQL等

当然，这些方式要基于业务的角度去选择，同事也要主要一些数据的**安全行**。

## 微前端方案之iframe和single-spa对比

### iframe

##### 缺点

1. 页面加载问题：影响页面加载，阻塞onload事件。
2. 布局问题：必须给iframe一个指定的高度，否则会塌陷。可以在子系统实时计算页面高度，通过`postMessage`发给组页面。
3. 弹窗及遮罩层：只能在`iframe`范围内。可通过页面通信有主页面实现。
4. 浏览器前进回退问题：浏览器的浏览历史记录无法记录。
5. iframe跳转到别的页面：只能通过主页面来实现跳转。
6. 不同源系统之间的通讯需要通过`postMessage`，存在一定的安全性。
7. 无法解决SEO的问题
8. 两个`iframe`页面相互引用会导致无限嵌套的问题，导致页面卡死。

##### 优点

1. 完全隔离了css和js，避免了各个系统之间的样式和js污染
2. 可以在子系统完全不修改的情况下嵌入

### single-spa

##### 缺点

1. css和js需要制定规范，进行隔离。否则容易造成全局污染，尤其是vue的全局组件、全局钩子。
2. 需要子系统配合修改。但不影响子系统独立开发部署，路由部分对子系统有一些改动，但是不影响功能。

##### 优点

1. 加载快，可以将所有系统共用的模块提取出来，实现按需加载，一次加载，其他的复用。
2. 修改子系统的样式，不需要代理服务器，直接修改，因为同属于一个`document`。
3. 用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染。
4. http请求少，服务器压力少。
5. 能解决SEO的问题

### single-spa和iframe对比

| 对比项   | single-spa                                                   | iframe                                                       | 补充                                                         |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 加载速度 | single-spa可以将所有系统共用的vue/vuex/vue-router等文件提取出来，只加载一次，各系统复用，加载速度很快，但是必须保证文件版本统一 | iframe会占用主系统的http通道，影响主系统的加载，加载速度很慢 | 两者都可以通过http缓存提高一定的加载速度，但是对于vue这些通用文件没法做cdn，因为内部系统很可能无法访问外网 |
| 兼容性   | single-spa只适用于vue、react、angular编写的系统，对一些jq写的老系统无能为力 | iframe则可以嵌入任何页面                                     |                                                              |
| 技术难度 | single-spa需要一定的技术储备，有一些学习成本                 | iframe门槛则很低，无需额外学习                               |                                                              |
| 局限性   | single-spa可以嵌入任何部件                                   | iframe只能嵌入页面，当然了也可以把一个部件单独写成一个页面   |                                                              |
| 改造成本 | single-spa一定要对子系统进行改造，但是改造的内容并不多很多，半小时即可完成 | iframe可以不对原系统进行改造，但是必须借助代理服务器进行插入脚本和css，增加了代理服务器也增加了系统的不稳定性（两台服务器中的任何一台挂掉都会导致系统不可用），服务器也需要成本。如对原系统进行改造，则工作量和single-spa相当 | 项目的源文件丢失或者其他一些无法改动源文件的情况，只能使用iframe |

### npm发包

##### 缺点

1. 当更新一个包的时候，使用它的那些团队都需要更新。

#####  优点

1. 直接将组件通过工程化安装到本地使用。

### git Submodule





#### 参考文章：

《[前端架构：从入门到微前端](https://item.jd.com/12621088.html)》

[微前端在美团外卖的实践](https://tech.meituan.com/2020/02/27/meituan-waimai-micro-frontends-practice.html)

[从0实现一个前端微服务](https://juejin.im/post/5e1c0fc7f265da3e413f4fe4#heading-9)

[使用npm发布一个vue组件](https://juejin.im/post/5d58fbb5e51d4561f17a50ac)

[Single-Spa微前端实践](https://juejin.im/post/5e1472836fb9a0482c4ea7c8#heading-10)