[toc]

# 浏览器渲染页面过程

1. DNS 查询
2. TCP 连接
3. HTTP 请求即响应
4. 服务器响应
5. 客户端渲染

## 从OSI七层模型看

1. 物理层
2. 数据链路层
3. 网络层
4. 运输层
5. 会话层
6. 表示层
7. 应用层

### DNS请求包的分析过程

先看应用层。是一个标准的DNS请求，里面包含要查询的域名，标志flags等。这些信息由应用程序生成。

再看传输层。用的是UDP协议，协议中标明了本地端口和目的端口号，报文长度等。

再看网络层。这一层用的是IP协议，其中包括了本地IP地址（src），目的地址（dst），数据包的生存时间（TTL）等，其中的protocol字段更是说明的了上层的协议类型，在目的端接收到这个包时解析用的。

再看数据链路层。这一层中加入了本机的MAC地址和目的的MAC地址，其中type中声明了上一层的协议类型是IP。

最后看物理层。包含一些数据概况，比如这个数据帧大小是73bytes，有584位等。

### DNS响应包

现在可以在应用层中看到百度的IP地址。

### TCP 连接

这个时候，浏览器已经产生一个HTTP包了，包头带着一个数据信息。

浏览器将这个HTTP信息包交给TCP(传输控制协议)（Transmission Control Protocol）,该协议运行于传输层。这是一个相邻的层之间进行交互的例子，较高层级（如HTTP）向较低层级（如TCP）表达服务需要，较低层级给较高层级提供服务。这种相邻层级的交互持续进行，直到抵达最底层。TCP的主要功能是与百度服务器的TCP程序进行连接并建立会话，就像在两者之间建立起一个管道那样，使两者之间的数据得以交互。

直到这个时候，信息包仍然呆在你的电脑里面，没有发出去呢。这个时候，TCP将TCP信息包转发给IP层（Internet Protocol）。  这是个网络层协议。IP的重要功能是寻址和路由，找到一条通往百度的IP地址的最优数据通路。就像一个邮局把你的信件寄到收件人那样。同时，IP将自己的信息加到原有的数据包上，形成新的数据包。

注意，直到这个时候，数据包还在你的电脑上呢，现在，数据包将由IP层交到网络接口层（network interface layer）。这个层定义了通过物理网络输出数据所需的协议与硬件要求。多数电脑使用以太网（Ethernet）。电脑这个时候将IP数据加上以太网帧头和帧尾打包成以太网帧。

这个时候，电脑就可以传输以太网帧的物理数据了，使用真正的电信号走网线传输了。数据包也在这个时候真正离开电脑。当这些电信号到达百度的服务器时，这些电信号将被重新翻译成二进制数据。服务器将对这个数据包进行解析，过程与上述形成该数据包的过程相反。当最后得到那个信息“度娘度娘，我要你的主页时”，服务器就会用刚才同样的步骤生成一个以太数据包通过因特网传给电脑。然后浏览器就可以显示百度主页的内容了。

## DNS查询

### 什么叫DNS

DNS的全称是domain name system，即域名系统。DNS是因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的去访问互联网而不用去记住能够被机器直接读取的IP地址。通过域名，最终得到该域名对应的IP地址的过程则是域名解析的过程。

### DNS如何解析

1、浏览器中输入想要访问的网站的域名，操作系统会先检查本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。

2、如果hosts里没有这个域名的映射，客户端会向本地DNS服务器发起查询。本地DNS服务器收到查询时，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析。

3、如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置，采用递归或者迭代查询，直至解析完成。

#### 递归查询

某天，客户端想要访问XXX网站，但是，客户端并不知道XXX网站的IP地址。于是，展开了如下对话

客户端：“本地DNS服务器大佬，求问XXX的IP地址是多少？”

本地DNS服务器：“不好意思，我不知道，但是根域名服务器可能会知道，我替去问他吧”

本地DNS服务器：“根域名服务器大佬，求问XXX的IP地址是多少？”

根域名服务器：“不好意思，我不也知道，但是A顶级域名服务器可能会知道，我替你去问他吧”

根域名服务器：“A顶级域名服务器，求问XXX的IP地址是多少？”

A顶级域名服务器：“不好意思，我不也知道，但是B域名服务器可能会知道，我替你去问他吧”

A顶级域名服务器：“B域名服务器，求问XXX的IP地址是多少？”

B域名服务器：“A顶级域名服务器，查到XXX的IP地址是192.168.168.6”

A顶级域名服务器：“根域名服务器，查到XXX的IP地址是192.168.168.6”

根域名服务器：“本地DNS服务器，查到XXX的IP地址是192.168.168.6”

本地DNS服务器： “客户端，查到XXX的IP地址是192.168.168.6”

客户端：“谢谢各位大佬，XXX的IP地址是192.168.168.6，我可以和他愉快的通讯了”

总结：递归查询时如果客户端所询问的本地域名服务器不知道被查询的域名的IP地址，那么本地域名服务器就以DNS客户的身份，向其他顶级域名服务器继续发出查询，直到查询到结果后，再层层传递回来。

#### 迭代查询

客户端：“本地DNS服务器大佬，求问XXX的IP地址是多少？”

本地DNS服务器：“不好意思，我不知道，但是根域名服务器可能会知道，你去问他吧”，本地DNS服务器说完，并把根域名服务器地址发给客户端。

客户端：“根域名服务器大佬，求问XXX的IP地址是多少？”

根域名服务器：“不好意思，我不也知道，但是A顶级域名服务器可能会知道，你去问他吧”，根域名服务器说完，并把A顶级域名服务器地址发给客户端。

客户端只能又跑去问A顶级域名服务器了。 客户端：“A顶级域名服务器大佬，求问XXX的IP地址是多少？”

A顶级域名服务器：“不好意思，我不也知道，但是B域名服务器可能会知道，你去问他吧”，A顶级域名服务器说完，并把B域名服务器地址发给客户端。

客户端非常无奈，只能又跑去问B域名服务器了。

客户端：“B域名服务器大佬，求问XXX的IP地址是多少？”

B域名服务器：“客户端同学，查到XXX的IP地址是192.168.168.6”。

客户端：“谢谢B域名服务器大佬，XXX的IP地址是192.168.168.6，我可以和他愉快的通讯了”

就这样，客户端在询问了一大圈之后，终于知道了XXX的IP地址了。

### DNS查询请求类型

1、权威答复：权威答复是返回给客户的正向答复，并且设置了DNS消息中的权威位。此答复代表从具有权威的DNS服务器处发出。

2、正向答复：正向答复包含了匹配客户端解析请求的资源记录。

3、参考答复：参考答复只在DNS服务器工作在迭代模式下使用，包含了其他有助于客户端解析请求的信息。例如，当DNS服务器不能为客户端发起的解析请求找到某个匹配值时，则向DNS客户端发送参考回复，告诉它有助于解析请求的信息。

4、否定答复：否定答复指出权威服务器在解析客户端的请求时可能遇到了以下两种情况之一：

权威DNS服务器报告客户端查询的名字不存在；

权威DNS服务器报告存在对应的名字,但是不存在指定类型的资源记录。

DNS服务器解析返回IP分配策略与客户端对域名IP选择策略,无论正向答复还是否定答复，DNS客户端都将结果保存在自己的本地缓存中

### DNS缓存

我们在使用浏览器访问互联网资源时,想获取指定的服务和信息。首先就要了解浏览器是如何定位到我们的站点的。输入一个域名(如:`www.baidu.com`)浏览器会首先从自身的缓存中查询是否有历史域名对应的IP并且有效，如果有就使用该缓存通过IP直接访问到指定的站点。如果没有则查询本地的Host缓存，如果有就使用本地的缓存直接访问站点，没有则向本地DNS服务器发起请求查询，如果本地DNS服务也没有找到，则向公网DNS服务发起查询请求获取对应的有效IP，并返回缓存到浏览器和本地缓存中，供后续请求使用。

DNS记录会有一个ttl值(time to live)，单位是秒，意思是这个记录最大有效期是多少。操作系统缓存会参考ttl值，但是不完全等于ttl值，而浏览器DNS缓存的时间跟ttl值无关，每种浏览器都使用一个固定值。

#### 浏览器缓存

浏览器在获取网站域名的实际IP地址后会对其IP进行缓存，减少网络请求的损耗。每种浏览器都有一个固定的DNS缓存时间。(可通过`cache-control`,`ETag`进行控制)

#### 本地缓存

每种操作系统都有自己的DNS缓存时间控制。

1、Windows DNS默认值是MaxCacheTTL，它的默认值是86400s，也就是一天。

2、MacOS遵循DNS协议中的TTL,根据各种网络协议不同对不同的域名采用不同的缓存时间策略。在IPv4包头中TTL是一个8 bit字段，它位于IPv4包的第9个字节。

在命令行执行`nslookup`指令可以看到一个域名对应的IP地址，并且可以帮助我们判断是否有DNS劫持。随便解析一个网站，比如[www.jd.com](https://link.jianshu.com?t=http://www.jd.com/)应该返回的是正常的地址,然后再解析一个不存在的网站，比如`123123.aaaa.com.cn`如果返回的结果是`DNS request timed out`.`timeout was 2 seconds`.那么证明你的DNS没有被劫持。如果返回的结果是一个IP地址，比如说网通的返回地址是`230.xxx.xxx.xxx`，那么证明你的DNS被劫持了。

## TCP 连接

### 什么是“3次握手，4次挥手”

TCP是一种面向连接的单播协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的“连接”，其实是客户端和服务器的内存里保存的一份关于对方的信息，如ip地址、端口号等。

TCP可以看成是一种字节流，它会处理IP层或以下的层的丢包、重复以及错误问题。在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在TCP头部。

TCP提供了一种可靠、面向连接、字节流、传输层的服务，采用三次握手建立一个连接。采用4次挥手来关闭一个连接。

### TCP服务模型

在了解了建立连接、关闭连接的“三次握手和四次挥手”后，我们再来看下TCP相关的东西。

一个TCP连接由一个4元组构成，分别是两个IP地址和两个端口号。一个TCP连接通常分为三个阶段：启动、数据传输、退出（关闭）。

当TCP接收到另一端的数据时，它会发送一个确认，但这个确认不会立即发送，一般会延迟一会儿。ACK是累积的，一个确认字节号N的ACK表示所有直到N的字节（不包括N）已经成功被接收了。这样的好处是如果一个ACK丢失，很可能后续的ACK就足以确认前面的报文段了。

一个完整的TCP连接是双向和对称的，数据可以在两个方向上平等地流动。给上层应用程序提供一种`双工服务`。一旦建立了一个连接，这个连接的一个方向上的每个TCP报文段都包含了相反方向上的报文段的一个ACK。

序列号的作用是使得一个TCP接收端可丢弃重复的报文段，记录以杂乱次序到达的报文段。因为TCP使用IP来传输报文段，而IP不提供重复消除或者保证次序正确的功能。另一方面，TCP是一个字节流协议，绝不会以杂乱的次序给上层程序发送数据。因此TCP接收端会被迫先保持大序列号的数据不交给应用程序，直到缺失的小序列号的报文段被填满。

### TCP头部

源端口和目的端口在TCP层确定双方进程，序列号表示的是报文段数据中的第一个字节号，ACK表示确认号，该确认号的发送方期待接收的下一个序列号，即最后被成功接收的数据字节序列号加1，这个字段只有在ACK位被启用的时候才有效。

当新建一个连接时，从客户端发送到服务端的第一个报文段的SYN位被启用，这称为SYN报文段，这时序列号字段包含了在本次连接的这个方向上要使用的第一个序列号，即初始序列号`ISN`，之后发送的数据是ISN加1，因此SYN位字段会`消耗`一个序列号，这意味着使用重传进行可靠传输。而不消耗序列号的ACK则不是。

头部长度（图中的数据偏移）以32位字为单位，也就是以4bytes为单位，它只有4位，最大为15，因此头部最大长度为60字节，而其最小为5，也就是头部最小为20字节（可变选项为空）。

ACK —— 确认，使得确认号有效。 RST —— 重置连接（经常看到的reset by peer）就是此字段搞的鬼。 SYN —— 用于初如化一个连接的序列号。 FIN —— 该报文段的发送方已经结束向对方发送数据。

当一个连接被建立或被终止时，交换的报文段只包含TCP头部，而没有数据。

### 为什么要“三次握手，四次挥手”

#### 三次握手

换个易于理解的视角来看为什么要3次握手。

客户端和服务端通信前要进行连接，“3次握手”的作用就是`双方都能明确自己和对方的收、发能力是正常的`。

`第一次握手`：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。

`第二次握手`：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。 从客户端的视角来看，我接到了服务端发送过来的响应数据包，说明服务端接收到了我在第一次握手时发送的网络包，并且成功发送了响应数据包，这就说明，服务端的接收、发送能力正常。而另一方面，我收到了服务端的响应数据包，说明我第一次发送的网络包成功到达服务端，这样，我自己的发送和接收能力也是正常的。

`第三次握手`：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的。 第一、二次握手后，服务端并不知道客户端的接收能力以及自己的发送能力是否正常。而在第三次握手时，服务端收到了客户端对第二次握手作的回应。从服务端的角度，我在第二次握手时的响应数据发送出去了，客户端接收到了。所以，我的发送能力是正常的。而客户端的接收能力也是正常的。

经历了上面的三次握手过程，客户端和服务端都确认了自己的接收、发送能力是正常的。之后就可以正常通信了。

每次都是接收到数据包的一方可以得到一些结论，发送的一方其实没有任何头绪。我虽然有发包的动作，但是我怎么知道我有没有发出去，而对方有没有接收到呢？

而从上面的过程可以看到，最少是需要三次握手过程的。两次达不到让双方都得出自己、对方的接收、发送能力都正常的结论。其实每次收到网络包的一方至少是可以得到：对方的发送、我方的接收是正常的。而每一步都是有关联的，下一次的“响应”是由于第一次的“请求”触发，因此每次握手其实是可以得到额外的结论的。比如第三次握手时，服务端收到数据包，表明看服务端只能得到客户端的发送能力、服务端的接收能力是正常的，但是结合第二次，说明服务端在第二次发送的响应包，客户端接收到了，并且作出了响应，从而得到额外的结论：客户端的接收、服务端的发送是正常的。

#### 四次挥手

TCP连接是双向传输的对等的模式，就是说双方都可以同时向对方发送或接收数据。当有一方要关闭连接时，会发送指令告知对方，我要关闭连接了。这时对方会回一个ACK，此时一个方向的连接关闭。但是另一个方向仍然可以继续传输数据，等到发送完了所有的数据后，会发送一个FIN段来关闭此方向上的连接。接收方发送ACK确认关闭连接。注意，接收到FIN报文的一方只能回复一个ACK, 它是无法马上返回对方一个FIN报文段的，因为结束数据传输的“指令”是上层应用层给出的，我只是一个“搬运工”，我无法了解`“上层的意志”`。

### “三次握手，四次挥手”怎么完成？

其实3次握手的目的并不只是让通信双方都了解到一个连接正在建立，还在于利用数据包的选项来传输特殊的信息，交换初始序列号ISN。

3次握手是指发送了3个报文段，4次挥手是指发送了4个报文段。注意，SYN和FIN段都是会利用重传进行可靠传输的。

#### 三次握手

1. 客户端发送一个SYN段，并指明客户端的初始序列号，即ISN(c).
2. 服务端发送自己的SYN段作为应答，同样指明自己的ISN(s)。为了确认客户端的SYN，将ISN(c)+1作为ACK数值。这样，每发送一个SYN，序列号就会加1. 如果有丢失的情况，则会重传。
3. 为了确认服务器端的SYN，客户端将ISN(s)+1作为返回的ACK数值。

#### 四次挥手

1. 客户端发送一个FIN段，并包含一个希望接收者看到的自己当前的序列号K. 同时还包含一个ACK表示确认对方最近一次发过来的数据。 
2. 服务端将K值加1作为ACK序号值，表明收到了上一个包。这时上层的应用程序会被告知另一端发起了关闭操作，通常这将引起应用程序发起自己的关闭操作。 
3. 服务端发起自己的FIN段，ACK=K+1, Seq=L 
4. 客户端确认。ACK=L+1

### 为什么建立连接是三次握手，而关闭连接却是四次挥手呢？

这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方是否现在关闭发送数据通道，需要上层应用来决定，因此，己方ACK和FIN一般都会分开发送。

## HTTP 请求即响应

一个HTTP 请求报文有以下几部分组成：

1. 请求行
2. 请求头部
3. 空行
4. 请求数据

请求头又是由以下几个字段组成：

1. 请求方法字段
2. URL字段
3. HTTP 协议版本(三者之间由空格分开)

方法字段会有GET POST HEAD PUT DELETE OPTIONS TRACE CONNECT 等几种方法，以下是GET方法的的请求报文：

```text
GET /search?hl=zh-CN&source=hp&q=domety&aq=f&oq= HTTP/1.1  
Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms-excel, application/vnd.ms-powerpoint, 
application/msword, application/x-silverlight, application/x-shockwave-flash, */*  
Referer: <a href="http://www.google.cn/">http://www.google.cn/</a>  
Accept-Language: zh-cn  
Accept-Encoding: gzip, deflate  
User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; TheWorld)  
Host: <a href="http://www.google.cn">www.google.cn</a>  
Connection: Keep-Alive  
Cookie: PREF=ID=80a06da87be9ae3c:U=f7167333e2c3b714:NW=1:TM=1261551909:LM=1261551917:S=ybYcq2wpfefs4V9g; 
NID=31=ojj8d-IygaEtSxLgaJmqSjVhCspkviJrB6omjamNrSm8lZhKy_yMfO2M4QMRKcH1g0iQv9u-2hfBW7bUFwVh7pGaRUb0RnHcJU37y-
FxlRugatx63JLv7CWMD6UB_O_r  
```

对于首部：格式为 首部名：(空格)首部值(回车换行)

- Accept: 客户端可以识别的响应内容类型的列表，如 image/gif, image/jpeg 可以对gif jpeg 格式的照片进行请求响应，“/”表示可以接受全部类型。
- Accept-Language：客户端可接受的语言
- Accept-Encoding：客户端可接受的编码压缩格式
- Accept-Charset：可接受的应答的字符集;
- Host: 请求的主机名，允许多个域名同处于一个IP地址(虚拟主机)
- connection：对于请求来说：close(告诉WEB 服务器或者代理服务器，在完成本次请求的响应后，断开连接，不等待本次连接的后续请求了)。keepalive(告诉WEB服务器或者代理服务器，在完成本次请求的响应后，保持连接，等待本次连接的后续请求);
- Cookie：[存储](https://link.zhihu.com/?target=http%3A//storage.chinabyte.com/)于客户端扩展字段，可以用来做用户认证，服务器校验，会话管理，个性化信息（记录用户相关的信息）等。
- 空行：空行标识请求头部的结束
- 主体：请求主体，在GET方法中这里一般会是空。

（请求中方法）

**GET：**要求服务器将请求报文中的url对应的资源放在响应报文的数据部分，然后回送给客户端，GET的URL中都会携带请求的参数，如：

```text
/index.jsp?id=100&op=bind
```

？代码URL的结束和请求参数的开始，id=100&op=bind就是参数，**这种方式决定GET方式不适合传递私密数据(参数会暴露信息)**,而且GET方式传输数据，**浏览器对字符也会有限制。**

**POST：该方法允许客户端给服务器传递更多的信息，POST的url中不会去显示请求参数，**POST方法将请求参数封装在请求数据中，＜request-body＞中，以名称/ 值得形式出现，可以传递大量数据。如下：

```text
POST /search HTTP/1.1  
Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms-excel, application/vnd.ms-powerpoint, 
application/msword, application/x-silverlight, application/x-shockwave-flash, */*  
Referer: <a href="http://www.google.cn/">http://www.google.cn/</a>  
Accept-Language: zh-cn  
Accept-Encoding: gzip, deflate  
User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; TheWorld)  
Host: <a href="http://www.google.cn">www.google.cn</a>  
Connection: Keep-Alive  
Cookie: PREF=ID=80a06da87be9ae3c:U=f7167333e2c3b714:NW=1:TM=1261551909:LM=1261551917:S=ybYcq2wpfefs4V9g; 
NID=31=ojj8d-IygaEtSxLgaJmqSjVhCspkviJrB6omjamNrSm8lZhKy_yMfO2M4QMRKcH1g0iQv9u-2hfBW7bUFwVh7pGaRUb0RnHcJU37y-
FxlRugatx63JLv7CWMD6UB_O_r  

hl=zh-CN&source=hp&q=domety
```

hl=zh-CN&source=hp&q=domety 就是请求的参数，参数的一般格式：数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，**POST方法大多数使用在页面表单中。**

**HEAD：** 和GET相似，只不过服务端只返回响应头部分，所以在我们查看页面的状态的时候，使用这个方法是非常高效的。

**PUT：**client对一个URI发送一个Entity，服务器在这个URI下如果已经又了一个Entity，那么此刻服务器应该替换成client重新提交的，也由此保证了**PUT的幂等性**。如果服务器之前没有Entity ，那么服务器就应该将client提交的放在这个URI上。

一个HTTP 响应报文有以下几部分组成：

1. 状态行
2. 空行
3. 请求数据

状态行：协议版本(空格)状态码(空格)短语
状态码：是由三位数字组成，第一位：响应的类型，常使用的有5大类型：

> 1xx: 服务器接收客户端请求，客户端可以继续发送请求
> 2xx: 服务器接收客户端请求并进行处理
> 3xx: 服务器要求客户端重定向：要求用户进一步细化请求
> 4xx: 客户端请求非法：客户错误
> 5xx: 服务器未能正常处理客户端的请求而出现意外：服务器发生错误

2xx: 服务器接收请求，并进行处理

```text
200：ok 客户端的请求成功收到、解析、接收
201：created 请求已经完成，并且一个新的返回资源被创建,被创建的资源可能是一个URI资源，通常URI资源在Location头指定。
202：Accepted 请求被接收用来处理，但是处理并没有完成，请求可能或者根本没有遵照执行
204：No Content 服务器已经接受请求并且没必要返回实体数据，可能需要返回更新信息
```

3xx：Redirection

```text
300 Multiple Choices 请求资源符合任何一个呈现方式。
01 Moved Permanently 请求的资源已经被赋予一个新的URI。

302 Found 通过不同的URI请求资源的临时文件。
303 See Other
```

4xx Client Error请求客户端错误

```text
400 Bad Request：表示客户端请求有语法错误，不能被服务器所理解;
401 Unauthonzed：表示请求未经授权，该状态代码必须与 WWW-Authenticate 报头域一  起使用;
403 Forbidden：表示服务器收到请求，但是拒绝提供服务，通常会在响应正文中给出不提供服务的原因;
404 Not Found：请求的资源不存在，例如，输入了错误的URL;
```

5xx 服务器错误

```text
500 Internal Server Error：表示服务器发生不可预期的错误，导致无法完成客户端的请求;
503 Service Unavailable：表示服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常;
502 Bad Gateway
501 Not Implemented 服务器没有相应的执行动作来完成当前请求。
503 Service Unavailable 因为临时文件超载导致服务器不能处理当前请求。
```

如下为一个响应的报文例子

```text
HTTP/1.1 200 OK                             //http协议版本  客户端响应成功
Date: Sat, 31 Dec 2005 23:59:59 GMT
Content-Type: text/html;charset=ISO-8859-1  //返回文档类型
Content-Length: 122                         //返回文档长度

＜html＞                                    //服务器返回给客户端的文本信息
＜head＞
＜title＞Wrox Homepage＜/title＞
＜/head＞
＜body＞
＜!-- body goes here --＞
＜/body＞
＜/html＞
```

有时候响应头中还会有：

> Location： 用于重定向接受者到一个新的位置,例如：客户端所请求的页面已不存在原先的位置，为了让客户端重定向到这个页面新的位置
> Connection: close(连接已经关闭); keepalive(连接保持着，在等待本次连接的后续请求); Keep-Alive：如果浏览器请求保持连接，则该头部表明希望WEB 服务器保持连接多长时间(秒);例如：Keep-Alive：300;

## 客户端渲染

1. 处理 HTML 标记并构建 DOM 树。
2. 处理 CSS 标记并构建 CSSOM 树。
3. 将 DOM 与 CSSOM 合并成一个渲染树。
4. 根据渲染树来布局，以计算每个节点的几何信息。
5. 将各个节点绘制到屏幕上。

需要明白，这五个步骤并不一定一次性顺序完成。如果 DOM 或 CSSOM 被修改，以上过程需要重复执行，这样才能计算出哪些像素需要在屏幕上进行重新渲染。实际页面中，CSS 与 JavaScript 往往会多次修改 DOM 和 CSSOM，下面就来看看它们的影响方式。

当然这只是从大体上来说。

实际上在浏览器拿到响应报文后立马开辟了一个栈内存，打开主线程，将字符串逐行压入栈中，执行完出栈。

例如`<!doctype html>`证明该文档类型是`html`，需要解析为`html`。

当遇到`<link>`,`<img>`,`<script>`等需要加载资源文件时需要开辟子线程，可以说是一个任务队列(Task Queue)，将请求添加到任务队列中，依次请求，在这个过程中，主线程继续执行，生成DOM树，在每一个css文件请求完后会生成一个cssom，二者再结合生成渲染树，当然在此过程中会触发回流或者重绘，下一个css文件来会进行同样的操作。

由此就可以简单得出浏览器的渲染过程

1. 解析HTML，生成DOM树，解析CSS，生成CSSOM树。
2. 将DOM树和CSSOM树结合，生成渲染树（Render Tree）
3. 回流：根据生成的渲染树，计算它们在设备视口内的确切位置和大小，这个计算的阶段就是回流
4. 重绘：根据渲染树以及回流得到的几何信息，得到节点的绝对像素
5. 将像素发送给GPU，展示在页面上

### DOM的重绘和回流

重绘：元素样式的改变（但宽高，大小，位置等不变）

如：`outline,visibility,color,background-color`等

回流：元素的大小或者位置发生了变化（当页面布局和几何信息发生变化的时候），触发了重新布局，导致渲染树重新计算布局和渲染。

如：添加或删除可见的DOM元素；元素的位置发生变化；元素的尺寸变化；内容发生变化；页面一开始渲染的时候；窗口变化。

注意：回流一定会触发重绘，重绘不一定会回流。

这时候就会有一个典型的性能优化点

### 避免DOM的回流

1. 放弃传统操作DOM的时代，基于vue/react开始数据影响视图模式

   `mvvm，virtual dom,dom diff`...

2. 分离读写操作（现代的浏览器都有渲染队列的机制）

   `offsetTop,offsetLeft,offsetWidth,offsetHeight,clientTop,clientLeft,clientWidth,clientHeight,scrollTop,scrollLeft,scrollWidth,scrollHeight,getComputedStyle,currentStyle...`会刷新渲染队列

3. 样式集中改变

   div.cssText = 'width:20px;height:20px'  div.ClassName = 'box';

4. 动画效果应用到`position`位置为`absolute`或`fixed`的位置上（脱离文档流）

5. CSS3硬件加速（GPU加速）

   比起考虑如何减少回流重绘，我们更期待的是，根本不要回流重绘；`transform\opacity\filters...`这些属性会触发硬件加速，不会引发回流和重绘

   可能会引发的坑：过度使用会占用大量内存，性能消耗严重，有时候会导致字体模糊等。

6. 牺牲平滑度换取速度

   每次1像素移动一个动画，但是如果此动画使用了100%的CPU，动画就会看上去是跳动的，因为浏览器正在与更新回流作斗争，每次移动3像素可能看起来平滑度低了，但它不会导致CPU在较慢的机器中抖动

7. 避免table布局和使用css的javascript表达式

### 阻塞渲染：CSS 与 JavaScript

谈论资源的阻塞时，我们要清楚，现代浏览器总是并行加载资源。例如，当 HTML 解析器（HTML Parser）被脚本阻塞时，解析器虽然会停止构建 DOM，但仍会识别该脚本后面的资源，并进行预加载。

同时，由于下面两点：

1. 默认情况下，CSS 被视为阻塞渲染的资源，这意味着浏览器将不会渲染任何已处理的内容，直至 CSSOM 构建完毕。
2. JavaScript 不仅可以读取和修改 DOM 属性，还可以读取和修改 CSSOM 属性。

存在阻塞的 CSS 资源时，浏览器会延迟 JavaScript 的执行和 DOM 构建。另外：

1. 当浏览器遇到一个 script 标记时，DOM 构建将暂停，直至脚本完成执行。
2. JavaScript 可以查询和修改 DOM 与 CSSOM。
3. CSSOM 构建时，JavaScript 执行将暂停，直至 CSSOM 就绪。

所以，script 标签的位置很重要。实际使用时，可以遵循下面两个原则：

1. CSS 优先：引入顺序上，CSS 资源先于 JavaScript 资源。
2. JavaScript 应尽量少影响 DOM 的构建。

浏览器的发展日益加快（目前的 Chrome 官方稳定版是 61），具体的渲染策略会不断进化，但了解这些原理后，就能想通它进化的逻辑。下面来看看 CSS 与 JavaScript 具体会怎样阻塞资源。

#### CSS

```html
<link rel="stylesheet" href="index.css">
```

这样的 link 标签（无论是否 inline）会被视为阻塞渲染的资源，浏览器会优先处理这些 CSS 资源，直至 CSSOM 构建完毕。

渲染树（Render-Tree）的关键渲染路径中，要求同时具有 DOM 和 CSSOM，之后才会构建渲染树。即，HTML 和 CSS 都是阻塞渲染的资源。HTML 显然是必需的，因为包括我们希望显示的文本在内的内容，都在 DOM 中存放，那么可以从 CSS 上想办法。

最容易想到的当然是**精简 CSS 并尽快提供它**。除此之外，还可以用媒体类型（media type）和媒体查询（media query）来解除对渲染的阻塞。

```rhtml
<link href="index.css" rel="stylesheet">
<link href="print.css" rel="stylesheet" media="print">
<link href="other.css" rel="stylesheet" media="(min-width: 30em) and (orientation: landscape)">
```

第一个资源会加载并阻塞。
第二个资源设置了媒体类型，会加载但不会阻塞，print 声明只在打印网页时使用。
第三个资源提供了媒体查询，会在符合条件时阻塞渲染。

#### JavaScript

JavaScript 的情况比 CSS 要更复杂一些。观察下面的代码：

```html
<p>Do not go gentle into that good night,</p>
<script>console.log("inline")</script>
<p>Old age should burn and rave at close of day;</p>
<script src="app.js"></script>
<p>Rage, rage against the dying of the light.</p>

<p>Do not go gentle into that good night,</p>
<script src="app.js"></script>
<p>Old age should burn and rave at close of day;</p>
<script>console.log("inline")</script>
<p>Rage, rage against the dying of the light.</p>
```

这样的 script 标签会阻塞 HTML 解析，无论是不是 inline-script。上面的 P 标签会从上到下解析，这个过程会被两段 JavaScript 分别打算一次（加载、执行）。

所以实际工程中，我们常常将资源放到文档底部。

#### 改变阻塞模式：defer 与 async

为什么要将 script 加载的 defer 与 async 方式放到后面呢？因为这两种方式是的出现，全是由于前面讲的那些阻塞条件的存在。换句话说，defer 与 async 方式可以改变之前的那些阻塞情形。

首先，注意 async 与 defer 属性对于 inline-script 都是无效的，所以下面这个示例中三个 script 标签的代码会从上到下依次执行。

```html
<!-- 按照从上到下的顺序输出 1 2 3 -->
<script async>
  console.log("1");
</script>
<script defer>
  console.log("2");
</script>
<script>
  console.log("3");
</script>
```

故，下面两节讨论的内容都是针对设置了 src 属性的 script 标签。

##### defer

```html
<script src="app1.js" defer></script>
<script src="app2.js" defer></script>
<script src="app3.js" defer></script>
```

defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。整个 document 解析完毕且 defer-script 也加载完成之后（这两件事情的顺序无关），会执行所有由 defer-script 加载的 JavaScript 代码，然后触发 DOMContentLoaded 事件。

defer 不会改变 script 中代码的执行顺序，示例代码会按照 1、2、3 的顺序执行。所以，defer 与相比普通 script，有两点区别：载入 JavaScript 文件时不阻塞 HTML 的解析，执行阶段被放到 HTML 标签解析完成之后。

##### async

```html
<script src="app.js" async></script>
<script src="ad.js" async></script>
<script src="statistics.js" async></script>
```

async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行——无论此刻是 HTML 解析阶段还是 DOMContentLoaded 触发之后。需要注意的是，这种方式加载的 JavaScript 依然会阻塞 load 事件。换句话说，async-script 可能在 DOMContentLoaded 触发之前或之后执行，但一定在 load 触发之前执行。

从上一段也能推出，多个 async-script 的执行顺序是不确定的。值得注意的是，向 document 动态添加 script 标签时，async 属性默认是 true。

#### document.createElement

使用 document.createElement 创建的 script 默认是异步的，示例如下。

```js
console.log(document.createElement("script").async); // true
```

所以，通过动态添加 script 标签引入 JavaScript 文件默认是不会阻塞页面的。如果想同步执行，需要将 async 属性人为设置为 false。

如果使用 document.createElement 创建 link 标签会怎样呢？

```js
const style = document.createElement("link");
style.rel = "stylesheet";
style.href = "index.css";
document.head.appendChild(style); // 阻塞？
```

其实这只能通过试验确定，已知的是，Chrome 中已经不会阻塞渲染，Firefox、IE 在以前是阻塞的，现在会怎样我没有试验。

#### document.write 与 innerHTML

通过 document.write 添加的 link 或 script 标签都相当于添加在 document 中的标签，因为它操作的是 document stream（所以对于 loaded 状态的页面使用 document.write 会自动调用 document.open，这会覆盖原有文档内容）。即正常情况下， link 会阻塞渲染，script 会同步执行。不过这是不推荐的方式，Chrome 已经会显示警告，提示未来有可能禁止这样引入。如果给这种方式引入的 script 添加 async 属性，Chrome 会检查是否同源，对于非同源的 async-script 是不允许这么引入的。

如果使用 innerHTML 引入 script 标签，其中的 JavaScript 不会执行。当然，可以通过 eval() 来手工处理，不过不推荐。如果引入 link 标签，我试验过在 Chrome 中是可以起作用的。另外，outerHTML、insertAdjacentHTML() 应该也是相同的行为，我并没有试验。这三者应该用于文本的操作，即只使用它们添加 text 或普通 HTML Element。

## 网页一秒内在移动网络上呈现完毕

### 适应高延迟的移动网络

我们必须假设每项网络请求的平均耗时将会是 100 毫秒。

基于这项假设，我们现在不妨逆向思考一下。如果我们仔细分析浏览器与服务器之间的典型通信过程，就会发现网络本身已经消耗掉了 300 毫秒的时间：一次 DNS 查找（用于将主机名（比如 google.com）解析为 IP 地址）、一次网络往返（用于执行 TCP 握手）以及一次可选的 TLS 连接。所以，留给我们的时间就只有 700 毫秒了。

### 在不到 1 秒的剩余预算内将内容呈现出来

在除去网络延迟之后，我们的预算就只剩下 700 毫秒了，但我们仍有大量的工作要做：服务器必须呈现响应内容，客户端应用代码必须得到执行，而且浏览器必须完成内容的布局和呈现。有鉴于此，以下标准应该能帮助我们在预算范围内搞定一切：

1. 服务器必须在 200 毫秒内呈现响应内容

   服务器响应时间就是在除去网络传输时间之后，服务器返回初始 HTML 所花费的时间。因为我们剩下的时间实在太少了，所以这个时间应该控制在最低限度：理想情况下应该保持在 200 毫秒以内，而且越少越好！

2. 应尽可能减少重定向次数

   额外的 HTTP 重定向可能会增加一次或两次额外的网络往返（如果需要再次查找 DNS 的话就是两次），这在 4G 网络上将会导致数百毫秒的额外延迟。因此，我们强烈建议网站站长尽可能减少重定向次数，而且最好完全消除重定向。这对 HTML 文档来说尤其重要（尽可能避免重定向到“m.”网址）。

3. 应尽可能减少首次呈现内容所需的网络往返次数

   鉴于 TCP 评估连接状况的方式（即TCP 慢启动），新的 TCP 连接无法立即使用客户端和服务器之间的全部有效带宽。因此，在通过新连接进行首次往返的过程中，服务器最多只能发送 10 个 TCP 数据包（约 14KB），然后必须等待客户端确认已收到这些数据，才能增大拥塞窗口并继续发送更多数据。

   另外还需注意的是，10 个数据包 (IW10) 这一限值源自 TCP 标准的最近一次更新：您应确保自己的服务器已升级到最新版本，以便能够充分利用这次更新。否则，这一限值可能会降低到 3-4 个数据包！

   考虑到 TCP 的这种行为，请务必优化您的内容，以尽可能减少为传输必要数据（以完成网页的首次呈现）而需进行的网络往返的次数。理想情况下，ATF 内容应小于 98KB，这样浏览器才能在 3 次网络往返之后即可显示网页内容，以便为服务器响应延迟和客户端呈现留出充足的时间预算。

4. 避免在首屏内容中包含会阻止内容呈现的外部 JavaScript 和 CSS

   浏览器必须先解析网页，然后才能将其呈现给用户。如果浏览器在解析过程中遇到非异步或阻止呈现的外部脚本，则必须停止解析并且下载相应资源。每当发生这种情况时，都会增加一次网络往返过程，这势必会导致网页的首次呈现时间被延迟。

   因此，用于呈现首屏内容的 JavaScript 和 CSS 应内嵌到网页中，而用于为网页增添附加功能的 JavaScript 或 CSS 应在 ATF 内容呈现完毕后再开始加载。

5. 为浏览器布局和呈现预留时间（200 毫秒）

   解析 HTML 和 CSS 以及执行 JavaScript 的过程同样需要消耗时间和客户端资源！这个过程可能需要耗用几百毫秒的时间，具体取决于移动设备的运行速度和网页的复杂程度。我们建议您为浏览器的开销预留 200 毫秒的时间。

6. 优化 JavaScript 的执行及呈现用时

   执行复杂的脚本和低效的代码可能会耗费数十甚至数百毫秒的时间 - 因此，必须要优化实现算法。

上面提到了慢启动，接下来提一下TCP的几种连接方式

## TCP慢启动、拥塞避免、快速重传、快速恢复

为了防止网络的拥塞现象，TCP提出了一系列的拥塞控制机制。最初由V. Jacobson在1988年的论文中提出的TCP的拥塞控制由“慢启动(Slow start)”和“拥塞避免(Congestion avoidance)”组成，后来TCP Reno版本中又针对性的加入了“快速重传(Fast retransmit)”、“快速恢复(Fast Recovery)”算法，再后来在TCP NewReno中又对“快速恢复”算法进行了改进，近些年又出现了选择性应答( selective acknowledgement,SACK)算法，还有其他方面的大大小小的改进，成为网络研究的一个热点。

TCP的拥塞控制主要原理依赖于一个拥塞窗口(cwnd)来控制，在之前我们还讨论过TCP还有一个对端通告的接收窗口(rwnd)用于流量控制。窗口值的大小就代表能够发送出去的但还没有收到ACK的最大数据报文段，显然窗口越大那么数据发送的速度也就越快，但是也有越可能使得网络出现拥塞，如果窗口值为1，那么就简化为一个停等协议，每发送一个数据，都要等到对方的确认才能发送第二个数据包，显然数据传输效率低下。TCP的拥塞控制算法就是要在这两者之间权衡，选取最好的cwnd值，从而使得网络吞吐量最大化且不产生拥塞。

由于需要考虑拥塞控制和流量控制两个方面的内容，因此TCP的真正的发送窗口=min(rwnd, cwnd)。但是rwnd是由对端确定的，网络环境对其没有影响，所以在考虑拥塞的时候我们一般不考虑rwnd的值，我们暂时只讨论如何确定cwnd值的大小。关于cwnd的单位，在TCP中是以字节来做单位的，我们假设TCP每次传输都是按照MSS大小来发送数据的，因此你可以认为cwnd按照数据包个数来做单位也可以理解，所以有时我们说cwnd增加1也就是相当于字节数增加1个MSS大小。

### 慢启动

最初的TCP在连接建立成功后会向网络中发送大量的数据包，这样很容易导致网络中路由器缓存空间耗尽，从而发生拥塞。因此新建立的连接不能够一开始就大量发送数据包，而只能根据网络情况逐步增加每次发送的数据量，以避免上述现象的发生。具体来说，当新建连接时，cwnd初始化为1个最大报文段(MSS)大小，发送端开始按照拥塞窗口大小发送数据，每当有一个报文段被确认，cwnd就增加1个MSS大小。这样cwnd的值就随着网络往返时间(Round Trip Time,RTT)呈指数级增长，事实上，慢启动的速度一点也不慢，只是它的起点比较低一点而已。我们可以简单计算下：

```text
   开始          --->     cwnd = 1

   经过1个RTT后   --->     cwnd = 2*1 = 2

   经过2个RTT后   --->     cwnd = 2*2= 4

   经过3个RTT后   --->     cwnd = 4*2 = 8

如果带宽为W，那么经过RTT*log2W时间就可以占满带宽。
```

### 拥塞避免

从慢启动可以看到，cwnd可以很快的增长上来，从而最大程度利用网络带宽资源，但是cwnd不能一直这样无限增长下去，一定需要某个限制。TCP使用了一个叫慢启动门限(ssthresh)的变量，当cwnd超过该值后，慢启动过程结束，进入拥塞避免阶段。对于大多数TCP实现来说，ssthresh的值是65536(同样以字节计算)。拥塞避免的主要思想是加法增大，也就是cwnd的值不再指数级往上升，开始加法增加。此时当窗口中所有的报文段都被确认时，cwnd的大小加1，cwnd的值就随着RTT开始线性增加，这样就可以避免增长过快导致网络拥塞，慢慢的增加调整到网络的最佳值。
上面讨论的两个机制都是没有检测到拥塞的情况下的行为，那么当发现拥塞了cwnd又该怎样去调整呢？

首先来看TCP是如何确定网络进入了拥塞状态的，TCP认为网络拥塞的主要依据是它重传了一个报文段。上面提到过，TCP对每一个报文段都有一个定时器，称为重传定时器(RTO)，当RTO超时且还没有得到数据确认，那么TCP就会对该报文段进行重传，当发生超时时，那么出现拥塞的可能性就很大，某个报文段可能在网络中某处丢失，并且后续的报文段也没有了消息，在这种情况下，TCP反应比较“强烈”：

1.把ssthresh降低为cwnd值的一半

2.把cwnd重新设置为1

3.重新进入慢启动过程。

从整体上来讲，TCP拥塞控制窗口变化的原则是AIMD原则，即加法增大、乘法减小。可以看出TCP的该原则可以较好地保证流之间的公平性，因为一旦出现丢包，那么立即减半退避，可以给其他新建的流留有足够的空间，从而保证整个的公平性。

其实TCP还有一种情况会进行重传：那就是收到3个相同的ACK。TCP在收到乱序到达包时就会立即发送ACK，TCP利用3个相同的ACK来判定数据包的丢失，此时进行快速重传

### 快速重传

1.把ssthresh设置为cwnd的一半

2.把cwnd再设置为ssthresh的值(具体实现有些为ssthresh+3)

3.重新进入拥塞避免阶段。

后来的“快速恢复”算法是在上述的“快速重传”算法后添加的，当收到3个重复ACK时，TCP最后进入的不是拥塞避免阶段，而是快速恢复阶段。快速重传和快速恢复算法一般同时使用。快速恢复的思想是“数据包守恒”原则，即同一个时刻在网络中的数据包数量是恒定的，只有当“老”数据包离开了网络后，才能向网络中发送一个“新”的数据包，如果发送方收到一个重复的ACK，那么根据TCP的ACK机制就表明有一个数据包离开了网络，于是cwnd加1。如果能够严格按照该原则那么网络中很少会发生拥塞，事实上拥塞控制的目的也就在修正违反该原则的地方。

### 快速恢复

1.当收到3个重复ACK时，把ssthresh设置为cwnd的一半，把cwnd设置为ssthresh的值加3，然后重传丢失的报文段，加3的原因是因为收到3个重复的ACK，表明有3个“老”的数据包离开了网络。

2.再收到重复的ACK时，拥塞窗口增加1。

3.当收到新的数据包的ACK时，把cwnd设置为第一步中的ssthresh的值。原因是因为该ACK确认了新的数据，说明从重复ACK时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态。

快速重传算法首次出现在4.3BSD的Tahoe版本，快速恢复首次出现在4.3BSD的Reno版本，也称之为Reno版的TCP拥塞控制算法。

可以看出Reno的快速重传算法是针对一个包的重传情况的，然而在实际中，一个重传超时可能导致许多的数据包的重传，因此当多个数据包从一个数据窗口中丢失时并且触发快速重传和快速恢复算法时，问题就产生了。因此NewReno出现了，它在Reno快速恢复的基础上稍加了修改，可以恢复一个窗口内多个包丢失的情况。具体来讲就是：Reno在收到一个新的数据的ACK时就退出了快速恢复状态了，而NewReno需要收到该窗口内所有数据包的确认后才会退出快速恢复状态，从而更一步提高吞吐量。

SACK就是改变TCP的确认机制，最初的TCP只确认当前已连续收到的数据，SACK则把乱序等信息会全部告诉对方，从而减少数据发送方重传的盲目性。比如说序号1，2，3，5，7的数据收到了，那么普通的ACK只会确认序列号4，而SACK会把当前的5，7已经收到的信息在SACK选项里面告知对端，从而提高性能，当使用SACK的时候，NewReno算法可以不使用，因为SACK本身携带的信息就可以使得发送方有足够的信息来知道需要重传哪些包，而不需要重传哪些包。

