GO（gloab object）：全局执行上下文，它存储的全局对象，GO == window

VO（variable object）：执行上下文相关的特殊对象，用来连接各个函数之间的关系。

AO（activation object）：活动对象，函数内的执行上下文对象。

AO主要针对的是函数的内部，而VO主要是关联函数与GO中对象的关系。

AO分为两个阶段，一个是声明阶段，一个是函数执行过程。这也体现了函数执行的三个过程：语法分析；预编译和解释执行。在预编译过程中会发生变量和函数的提升，需要注意的是：函数的提升等级比变量高；只声明不赋值不会覆盖之前变量的内容。在声明的过程中变量和匿名函数变量为undefined，函数就是函数，这个过程发生在预编译中；在函数执行过程中一步一步的赋值，这也就解释了this的问题。

在函数执行过程中会形成EC（exectution context），ECS（execution context stack）执行上下文栈，用来管理多个函数执行上下文，他会按照js的执行顺序将多个EC入栈到ECS中，每执行完一个函数，就会销毁这个函数。

在函数声明的过程中，就开始形成AO，同时生成了这个函数的作用于连【scopes】, 我们可以将这个作用域链看做是一个栈，全局的GO永远在栈低，刚开始时既是栈低又是栈顶。然后会将函数AO入栈，这这样优先获取到就是AO，其次是GO。当然我们也要将GO和AO分别看做一个栈，按照js执行的过程来说，在预编译的过程中，会进行函数和变量的提升，按照提升的顺序，将函数和变量依次入栈，在函数执行的过程中，再将这些函数和变量的声明按照执行顺序依次入栈，这样就行成了函数的作用域链，在取值的时候就优先从函数的AO中取值，先从AO中依次出栈，对比是不是要找的，然后再去GO中去找，只要找到就暂停这个步骤。



