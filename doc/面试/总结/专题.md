[toc]

## 自我介绍

#### boss简介

您好，对贵公司此岗位感兴趣，本人有四年前端开发经验。

【技术栈】vue全家桶、webpack、nodejs express/koa搭建中间层或后端服务、typescript、jenkins。

【前端能力】能独立搭建h5和PC端高质量的spa框架、node中间层。对项目性能进行优化，优化首屏加载速度和缩短白屏时间，提升40%打包效率。有能力攻克难点新技术和解决团队技术问题。对接微信、支付宝生态，搭建完整业务体系，并对核心功能(用户系统，支付系统)基础服务化。

【md笔记】https://github.com/Jokul518/fe-growth-path

#### 开场

你好，我叫郭豪豪。现在的公司叫特微智能，主要业务是高速相关的业务，扫码支付和etc服务，我之前是在车主服务部门，我们部门主要的业务是做会员服务，主要平台是微信和支付宝的h5以及小程序。我主要的负责纵横黑卡和金卡项目，包括一期的项目搭建以及二期的项目重构。主要技术展示node express+ejs+jq，二期是vue的单页面。高速运营部门 全国视频上云pc端管理系统。上一家公司是在一牧科技，主要业务是牧场相关的生产管理系统以及数据分析系统，主要帮助牧场实现数字化管理生产，提供数据搜集、数据分析以及生成每天的工作内容等，还有就是可视化大屏、生产指标报告等。主要技术栈是 jq vue node koa ts echarts。

#### 项目

纵横黑金卡：主要负责整个项目的开发规划，项目搭建、开发的规范制定、公共方法和组件的封装、问题解决以及打包的优化。**重构原因**，其他技术人员的技术栈以及项目的业务需求，更换前端整体UI风格。**公共组件方法**：抽奖转盘、支付按钮、自定义指令。**cli的打包优化**，路由懒加载、配置别名、第三方库按需加载、uglifyjs-webpack-plugin 对代码进行压缩、上线清除console等、webpack-deep-scope-plugin css-nano 进行tree-sharking、dllplugin和dllreferanceplugin 优化webpack编译速度、commonsChunkPlugin到splitChunkPlugin的优化、骨架屏、做预渲染。

项目功能： 秒杀、限时抢购、转盘抽奖

#### 秒杀

#### 秒杀与限时抢购

**🍊架构上**： 功能单独部署，两+台服务器同时部署。没有cdn，图片放在oss上，静态资源走强缓（在nginx的location中根据文件名或者文件路径或者正则匹配设置expires cache-control）。

🍊**前端限制**：按钮节流；到时显示；按钮点击后置灰，响应后显示；发送请求是也限制时间；请求也在后端进行时间限制；下单时会确定有效订单数不超过产品数，订单存在时间为5分钟，超时支付时前端提示不支付，后台删除订单，支付成功后后台校验下单时间和订单。限制用户在2秒之内只能提交一次请求; 

🍊**倒计时问题**：首先以客户端事件为准设置定时器，点击按钮后从服务端拿时间重新设置定时器，三分钟内只发一次请求。

🍊**限制一定时间内只发送一次请求**：节流





## js篇

#### [js执行堆栈](https://www.yuque.com/guohh/yo6wpa/odprhy)

🍊**可执行上下文栈**：js 在执行脚本的时候首先会创建一个全局可执行上下文globalContext，每执行一个函数就会创建这个函数的可执行上下文executionContext。为了管理这些可执行上下文，js引擎维护了执行上下文栈Execution Context Stack来管理这些可执行上下文。就是js同步执行队列。当函数调用完成后，就会把当前函数的执行上下文销毁，回到上一个执行上下文...这个过程反复执行，直到执行栈中的胆码执行完毕，go永远存在于ecs的栈低，直至该脚本执行完毕。

🍊**AOVOGO**： **变量对象VO**与可执行上下文相关的特殊对象，用来存储上下文中的**函数声明、形参**和**变量**。在函数上下文中，变量对象会被激活为**活动对象AO**，分为创建阶段和执行阶段。它包含VO内的并且包含**scopeChain**、一系列父执行上线文**VO**、**Scope：[AO,barExecutionContext.AO,globalContext.VO]**、**this**(运行时确认)。

🍊 **作用域链的原理**就是Scope:[AO,barExecutionContext.AO,globalContext.VO]。**闭包的原理**就是Scope，当bar环境已经被销毁，但是foo的作用域链中还保存着bar中的变量，这就形成了闭包。**this的原理**就是动态绑定，永远指向ECS的栈顶。**变量提升**发生在AO的准备阶段。**异步队列的原理**就是ECS。

#### [作用域](https://www.yuque.com/guohh/yo6wpa/zfpha4) 与[闭包](https://www.yuque.com/guohh/yo6wpa/qgb4o6)

🍊**编译原理**：词法分析、语法分析和代码生成。

🍊**作用域**分为静态作用域和动态作用域。静态作用域是在定义的时候确定了变量的值，而动态作用域是在执行的时候确定变量的值。js采用的就是静态作用域，js的作用域又叫做词法作用域，是与词法分析器处理代码时会保持词法作用域不变。js作用域又分为函数作用域和块级作用域。函数作用域就是在函数的全部变量可以在整个函数的范围内使用及复用，包括它内部的嵌套作用域。块级作用域 ，ES5实现块级作用域的方式有：eval、with、try/catch的catch分句、闭包。ES6的就是let和const。

🍊**作用域链**：作用域链的产生是因为作用域发生嵌套。它是当前作用域环境和上层环境的一系列变量对象组成的，它保证了当前执行环境对符合访问权限的变量和函数的有序访问。当查找变量的时候，首先会在当前作用域内查找，如果没有，则去上层作用域环境查找，直到找到全局上下文及全局变量。这个由多个执行上下文的变量对象构成的链表叫做作用域链。

🍊**闭包：**MDN的概念是：那些能访问自由变量的函数就是闭包。自由变量是既不是函数的参数也不是函数内部声明的变量。**实际上**即使创建它的上下文已经被销毁，它依然存在，并引用自由变量。闭包是在函数被调用的时候才会被确定创建的，闭包的形成与作用域链的访问顺序有直接的关系，只有内部函数访问上层作用域链中的变量对象才会形成闭包。**闭包的好处：**立即执行函数、类库封装、隔离作用域、避免变量污染、实现类和继承。**闭包的缺点：**内存泄露、this指向、引用的外部变量修改时不会在闭包内生效、for循环形成闭包。**哪些是闭包：**所有的回调函数、定时器、事件触发、监听。 **闭包的优化**：回调函数避免使用自由变量、及时将定时器置为null、及时清除监听的事件。**造成内存泄露的原因：**全局变量、闭包、dom删除或者清空时绑定的事件未清除。

🍊 **将闭包和作用域链的原理引到js执行上下文。**

#### 原型链

![](https://cdn.nlark.com/yuque/0/2019/png/225909/1574826330223-ec376534-f1ac-4318-8b07-ef08d6d870aa.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_Sm9rdWw=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10)

1. **实例的隐式原型等于构造函数的显式原型**，f1.**proto**==Foo.prototype
2. 函数类型有prototype，对象有**proto**
3. 所有的构造函数也属于函数，所以Foo/Object.**proto**==Function.protoype
4. 函数的构造函数也属于函数，所以Function.**proto**== Function.protoype
5. Object.prototype.**proto** == null

#### new和继承

🍊[继承](https://www.yuque.com/guohh/yo6wpa/clqwov)

1. 原型链

2. 借用构造函数

3. 组合继承

4. 原型式继承

5. 寄生式继承

6. 寄生组合式继承

🍊[new](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new)

1. 创建一个空的简单JavaScript对象（即`**{}**`）；
2. 链接该对象（即设置该对象的构造函数）到另一个对象 ；
3. 将步骤1新创建的对象作为`**this**`的上下文 ；
4. 如果该函数没有返回对象，则返回`**this**`。

```javascript
function objectFactory() {
    var obj = new Object(),
    Constructor = [].shift.call(arguments);
    obj.__proto__ = Constructor.prototype;
    var ret = Constructor.apply(obj, arguments);
    return typeof ret === 'object' ? ret : obj;
};
```

#### [类型判断](https://www.yuque.com/guohh/yo6wpa/dxdagg)

用 typeof 来判断变量类型的时候，我们需要注意，最好是用 typeof （**除了Function之外的所有构造函数的类型都是'object'。**）来判断基本数据类型（包括symbol），避免对 null 的判断。不过需要注意当用typeof来判断null类型时的问题，如果想要判断一个对象的具体类型可以考虑使用instanceof（**instanceOf的主要实现原理就是只要右边变量的prototype在左边变量的原型链上即可**），但是很多时候它的判断有写不准确。所以当我们在要准确的判断对象实例的类型时，可以使用`Object.prototype.toString.call()`进行判断。因为`Object.prototype.toString.call()`是引擎内部的方式。

#### [this指向](https://www.yuque.com/guohh/yo6wpa/ywp22q)

1. 全局环境、普通函数（非严格模式）this都指向window

2. 普通函数（严格模式）指向undefined
3. 函数作为对象方法及原型链指向的都是上一级对象
4. 构造函数指向构造的实例
5. DOM事件中指向触发事件的元素
6. 箭头函数指向它父级的环境

#### [异步事件队列](https://www.yuque.com/guohh/yo6wpa/tmazrg)

🍊**五大线程:**GUI渲染线程、js引擎线程、事件触发线程、定时处理线程、异步http请求线程

🍊**事件循环：**事件循环机制和异步队列的维护是由事件触发线程控制的。它维护一个异步事件队列。JS引擎会维护一个同步执行栈，同步代码会依次加入执行栈中进行，执行结束后出站。如果遇到异步，就会交给对应的线程来完成异步任务，等异步任务执行完成，然后由事件触发线程将异步对应的回到函数加入到异步事件队列中。等同步执行栈中的任务执行完毕，事件触发线程就会从异步事件中取出最先加入的异步回调函数进行执行，提取规则遵循先入先出的规则，异步事件队列类似队列的数据结构。

🍊**微任务宏任务**

**macrotask:**

- 主代码块

- setTimeout

- setInterval

- I/O（ajax）

- UI rendering

- setImmediate(nodejs)

- 可以看到，事件队列中的每一个事件都是一个 macrotask，现在称之为宏任务队列

**microtask:**

- Promise

- Object.observe(已经废弃)

- MutationObserver

- process.nextTick(nodejs)

**执行顺序**

1. 执行一个宏任务（栈中没有就从事件队列中获取，可以理解为一个script标签）
2. 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中
3. 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）
4. 当前微任务执行完毕，开始检查渲染，然后GUI线程接管渲染
5. 渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）

![微任务宏任务](https://cdn.nlark.com/yuque/0/2019/png/225909/1576857708932-a255d383-b096-4be9-82f2-2d06ebb8a1de.png)

#### [数据存储](https://www.yuque.com/guohh/yo6wpa/ykuyfv)

#### 数组API

构造函数。静态方法Array.isArray()。实例方法valueOf()，toString()、push()、pop()、shift()，unshift()、join()、concat()、reverse()、slice()、splice()、sort()、`map()、forEach()、filter()、some()，every()、reduce()、reduceRight()`、 indexOf()、lastIndexOf()链式使用

#### 对象API

##### **Object.create()**

创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。

##### Object.defineProperties()

直接在一个对象上定义新的属性或修改现有属性，并返回该对象。`Object.defineProperties(obj, props)`

- `configurable`

  `true` 当且仅当该属性描述符的类型可以被改变并且该属性可以从对应对象中删除。 **默认为 `false`**

- `enumerable`

  `true` 当且仅当在枚举相应对象上的属性时该属性显现。 **默认为 `false`**

- `value`

  与属性关联的值。可以是任何有效的JavaScript值（数字，对象，函数等）。 **默认为 [`undefined`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined).**

- `writable`

  `true`当且仅当与该属性相关联的值可以用[assignment operator](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Assignment_Operators)改变时。 **默认为 `false`**

- `get`

  作为该属性的 getter 函数，如果没有 getter 则为[`undefined`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined)。函数返回值将被用作属性的值。 **默认为 [`undefined`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined)**

- `set`

  作为属性的 setter 函数，如果没有 setter 则为[`undefined`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined)。函数将仅接受参数赋值给该属性的新值。
  **默认为 [`undefined`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined)**

##### Object.defineProperty()

直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。`Object.defineProperty(obj, prop, descriptor)`

* obj 要在其上定义属性的对象。

* prop 要定义或修改的属性的名称。
* descriptor 将被定义或修改的属性描述符

 

## ES6篇

#### commonJS和ES6 modules

common

#### [ let、const](https://es6.ruanyifeng.com/#docs/let)

#### let、const](https://es6.ruanyifeng.com/#docs/let)



#### [数组新方法](https://es6.ruanyifeng.com/#docs/array)

扩展运算符

Array.from

array.of

copyWith

find() findIndex

fill()

entries keys values includes flat flatMap

#### [新的数据类型](https://es6.ruanyifeng.com/#docs/object-methods)



#### [promise方法](https://es6.ruanyifeng.com/#docs/promise)

#####  原理

promise是前端异步编程的一种解决方案，它其实使用的也是回调函数，只不过是封装在内部的，使用then方法的链式调用。主要是resolve then 和reject实现整个流程。

它内部有一个状态管理器，它有三种状态， pending、 fulilled、rejected。状态一旦修改就不能再变。调用resolve ☞ fulilled，调用reject ☞ rejected。 

promise内主要有三个变量，promise状态变量、执行结果、和为then链式调用注册的回调处理数组（每个then都会创建一个新的promise）。

##### then方法

then方法可以被同一个promise调用多次，每次返回一个新的promise对象。它有两个可选参数onResolved和onRejected。为什么每次都返回一个新的promise？如果不是一个新的promise那么就会导致所有的then方法的执行结果一致了，就会出现矛盾。

##### resolve函数

promise实例化时立即执行传入的fn函数，同时传递内部resolve函数作为参数用来改变promise状态。执行逻辑是判断并改变当前promise状态，存储函数的值。然后判断当前是否存在then的执行回调函数(defferd数组)，存在则遍历数组执行回调。

##### reject函数

修改执行状态和存储错误原因，然后执行then的回调函数数组

##### 缺点

1. 无法取消promise，一旦创建立即执行，无法中途取消
2. 如果不设置回调函数，promise内部抛出的错误，不会反应到外部
3. 当处于pending状态时，无法知道进展到哪个阶段

##### 其他方法

* **catch:** 是promise发生错误时的回调函数
* **finally:** 无论什么执行结果都会调用，但拿不到promise的执行结果
* **all:**将多个promise实例包装成一个promise实例，所有结果都为resolve时，然后的promise才为resolve，返回值为所有promise结果的数组。返回reject时返回值为第一个reject的值。
* **rece:**同all函数，结果为最先返回状态的那个promise结果。
* ...

#### [generator](https://es6.ruanyifeng.com/#docs/generator)

可以理解为一个状态机，封装了多个内部状态。它是一个封装的异步任务或者说是异步任务的容器，异步操作需要暂停的地方都用yield语句。星号、yield、next

#### [async函数](https://es6.ruanyifeng.com/#docs/async)

generator点的语法糖，返回一个promise函数。

#### [class的实现原理](https://es6.ruanyifeng.com/#docs/class-extends)

## CSS篇

#### flex布局

##### 父属性

1. flex-direction   主轴方向 row | row-reverse | column | column-reverse;
2. flex-wrap  是否换行  nowrap | wrap | wrap-reverse 
3. flex-flow  前两个属性的缩写
4. justify-content 主轴方向对齐方式 flex-start|flex-end|center|space-between|space-around 
			space-between：两端对齐，项目之间的间隔都相等。
			space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。
5. align-items 交叉轴方向对齐方式 flex-start|flex-end|center|baseline|stretch
			baseline: 项目的第一行文字的基线对齐。
			stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。
6. align-content 多条轴线对齐方式 flex-start|flex-end|center|space-between|space-around|stretch
			space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。
			space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。
			stretch（默认值）：轴线占满整个交叉轴。

##### 子属性

1. order 排序方式 越小越靠前
2. flex-grow 放大比例 默认0
3. flex-shrink 缩小比例 0 
4. flex-basis 占据的主轴空间
5. flex 表示占比  flex-grow | flex-shrink | flex-basis缩写
6. aligh-self 自己的排列方式 auto | flex-start | flex-end | center | baseline | stretch

#### 等高

#### 多列

#### 清除浮动

#### 动画

#### [css3新特性]( https://juejin.im/entry/595f1e3c5188250d914dd53c) 

​	1. 选择器 模糊匹配  

  2. transition transform animation
  3. 边框
  4. 背景新方法
  5. 文字效果
  6. 渐变
    7. @font-face特性
  8. 多列布局
    9. resize box-sizing outline-offset

#### 可继承属性

##### 字体系列属性 

* font-family 
* font   组合字体
* font-weight  字体粗细
* font-size  字体大小
* font-style  字体风格
* font-variant  偏大或偏小的字体

##### 文本系列属性

* text-indent  文本缩进
* text-aligh  水平对齐
* line-height  行高
* word-spacing   单词间隔
* letter-spacing  字符间隔
* text-transform  文字大小写 
* direction 文本方向
* color  颜色

##### 元素可见性

* visibility

##### 表格布局属性 

* caption-side定位表格标题位置
* border-collapse合并表格边框
* border-spacing设置相邻单元格的边框间的距离
* empty-cells单元格的边框的出现与消失
* table-layout表格的宽度由什么决定<automatic.fixed.inherit>

##### 列表布局属性

* list-style-type文字前面的小点点样式
* list-style-position小点点位置
* list-style以上的属性可通过这属性集合

##### 引用

* quotes设置嵌套引用的引号类型

##### 光标属性

* cursor 变箭头

#### 不可继承属性

##### display

##### 文本属性

vertical-align 垂直居中

text-decoration  文本装饰

text-shadow 文本阴影

white-space 空白符的处理

##### 盒模型

width、height、margin 、margin-top、margin-right、margin-bottom、margin-left、border、border-style、border-top-style、border-right-style、border-bottom-style、border-left-style、border-width、border-top-width、border-right-right、border-bottom-width、border-left-width、border-color、border-top-color、border-right-color、border-bottom-color、border-left-color、border-top、border-right、border-bottom、border-left、padding、padding-top、padding-right、padding-bottom、padding-left

##### 背景属性

background、background-color、background-image、background-repeat、background-position、background-attachment

##### 定位属性

float、clear、position、top、right、bottom、left、min-width、min-height、max-width、max-height、overflow、clip、z-index

## vue篇

### vue双向数据绑定原理

1. vue是采用数据劫持结合发布者-订阅者模式的方法，通过`Object.defineProperty()`来劫持各个属性的setter、getter，在数据变动时发布消息给订阅之，触发相应的监听事件。主要有watcher、dep、observer和complier四块。
2. 第一步：需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter，这样给任何值赋值是都会触发setter，就能进行数据变化的监听
3. 第二步：compile解析模板指令，将模板中的变量替换数据，然后初始化渲染页面视图，并将每个执行对象的节点绑定更新函数，添加监听数据的订阅者，一旦数据变化没收到通知就更新视图。
4. 第三步：watcher订阅者是Observe和compile之间的栋梁；①在自身实例化时往属性订阅器dep里添加自己②自身必须有一个update方法③带属性变动dep.notice()通知时，能调用自身的update方法，并触发compile中绑定的回调
5. 第四步：MVVM作为数据绑定的入口，整合observe和compile和watcher三者，通过observe来监听自己的数据变化，通过compile来解析末班执行，最终利用watcher搭起observe和compile之间的通信，达到数据变化就更新视图，视图交互就更新数据的效果
6. 注意：`Object.defineProperty()`只能更新data已有数据的setter和getter，如果给data挂载新的属性时，需手动添加到dep和数据监听。
7. 流程：通过defineReactive方法，使用`Object.defineProperty()`劫持对象的取值赋值，添加订阅者watcher到主题对象Dep，确保只有同一个变量只有一个watcher添加到dep数组中。☞ dep中往dep数组中添加watcher和监听dep中的每一个watcher。☞ Watcher是将模板和Observer对象结合在一起的纽带。Watcher是订阅者模式中的订阅者。update是将更新操作添加到批处理中进行操作，用来提高性能。cb是批处理的回调。☞`Compile`用来接受Watcher的通知，将修改的数据的通过生成虚拟dom，然后转成真实dom，表现到页面上。☞ 这里使用一个while循环，避免使用递归碰到大量的node节点，出现性能瓶颈。

### 数组的重写

当通过` Object.defineProperty`对对象和数组进行劫持setter、getter方法时，只能对对象和数组内原有属性的劫持，如果新增属性，需要重新劫持，调用`defineReactive`方法，添加watcher和dep。需要注意的是当对已有属性进行修改时，会调用setter和getter方法，` Object.defineProperty`监听数组时，可以理解为将数组的下标当做对象的key来处理的，所以当数组处理操作涉及到下标时就会出现性能问题。

```javascript
// vue 源码中的书写方式
function defineReactive(obj,key,value){
    Object.defineProperty(obj,key,{
        enumerable:true,
        configurable:true,
        get: function reactiveGetter () {
            console.log(`get ---- key:${key} 获取值:${value}`)
            return value;

        },
         set: function reactiveSetter (newVal) {
             console.log(`set ---- key:${key}  设置值:${newVal}`)
             value = newVal
         }
    })
}

function observer(data){
    Object.keys(data).forEach(function(key){
        defineReactive(data,key,data[key])
    })
}
var arr = ['a','b','c','d']
observer(arr);
arr.shift();
// 输出结果 ☞☞☞
// get ---- key:0 获取值:a
// Object.defineProperty:8 get ---- key:1 获取值:b
// Object.defineProperty:13 set ---- key:0  设置值:b
// Object.defineProperty:8 get ---- key:2 获取值:c
// Object.defineProperty:13 set ---- key:1  设置值:c
// Object.defineProperty:8 get ---- key:3 获取值:d
// Object.defineProperty:13 set ---- key:2  设置值:d
```

数组的那些操作会触发呢？`push`、`pop`、`shift`、`unshift`、`splice`、`sort`、`reverse`这7个方法会造成严重的性能问题，所以这里修改了数组的这些方法的处理方式，劫持方法，手动给新元素添加监听。

```javascript
[
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
]
.forEach(function (method) {
  // cache original method
  /*将数组的原生方法缓存起来，后面要调用*/
  const original = arrayProto[method]
  def(arrayMethods, method, function mutator () {
    // avoid leaking arguments:
    // http://jsperf.com/closure-with-arguments
    let i = arguments.length
    const args = new Array(i)
    while (i--) {
      args[i] = arguments[i]
    }
    /*调用原生的数组方法*/
    const result = original.apply(this, args)

    /*数组新插入的元素需要重新进行observe才能响应式*/
    const ob = this.__ob__
    let inserted
    switch (method) {
      case 'push':
        inserted = args
        break
      case 'unshift':
        inserted = args
        break
      case 'splice':
        inserted = args.slice(2)
        break
    }
    // 如果存在参数，就手动给数组新元素手动添加observer
    if (inserted) ob.observeArray(inserted)
      
    // notify change
    /*dep通知所有注册的观察者进行响应式处理*/
    ob.dep.notify()
    return result
  })
})

// ob.observeArray() 调用array.js中的方法  86行
/**
   * Observe a list of Array items.
   */
/*对一个数组的每一个成员进行observe*/
observeArray (items: Array<any>) {
  for (let i = 0, l = items.length; i < l; i++) {
    /*数组需要遍历每一个成员进行observe*/
    observe(items[i])
  }
}
```

### vue生命周期

1. **beforeCreate：**vm实例刚刚创建，什么属性都没有挂载到VM实例上
2. **created：**vm实例创建完成，vm上的属性（data，method）已全部绑定，但是el还不存在
3. **beforeMount：**完成el的初始化，但未挂载到页面
4. **mounted：**el挂载到页面，此时已挂载的数据，不适合处理异步请求的接口数据
5. **beforeUpdate：**更新前，数据已修改完成，但是为渲染到页面
6. **updated：**修改完成，此时可以处理异步请求的接口数据，适合处理统一变化的数据，也可以用$nextTick()，它表示DOM完成更新完毕
7. **beforeDestroy：**vm实例销毁之前，此时实例依然可以用
8. **destroyed：**vm实例销毁后移除实例上所有的绑定和事件的监听

**注意：服务端渲染中只有前两个生命周期**

### for循环加key的原理

使用`v-for`更新已渲染的元素列表时,默认用`就地复用`策略;列表数据修改的时候,他会根据key值去判断某个值是否修改,如果修改,则重新渲染这一项,否则复用之前的元素; 

因为vue组件高度复用，增加key可以标识组件的唯一性，为了更好的区别各个组件的key的作用。**key的作用主要是为了高效的更新虚拟DOM。**

### Vuex

它的主要作用就是帮助我们更好的管理组件间的数据。

**应用场景：**根组件下的深层次组件进行数据交互的时候需要经过很多层到达根组件再到子组件，所以就需要一个工具帮助我们去管理这些数据，vuex的作用就是提供这么一个store来管理数据的状态。通过getter方法获取数据，通过mutation方法来修改数据源。我觉得它就是**用来管理vue各个组件中要用到的变量，也就是全局变量**。

**使用方法：**在store.js中通过Vue.use(vuex)将vuex挂载到vue对象上，然后通过export default/ exprot new Vue.store({})输出一个对象，将所有的全局变量挂到对象上，然后在vue实例中使用。

**核心概念：**

state：声明全局变量，通过this.$store.state即可调用。

getter：相当于computed计算属性，用于监听计算state中值的变化

mutation：同步操作数据的方法

action：用来调用mutation的方法，不能直接操作数据源（规定的），相当于将mutation变为异步

module：模块化，将vuex分成多个子模块

### vue指令

```javascript
/*  自定义指 */
import Vue from 'vue'
/**
 * 模板
 * v-lang
 * 五个注册指令的钩子函数
 */
Vue.directive('mydirective', {
  /**
   * 1.被绑定
   * 做绑定的准备工作
   * 比如添加事件监听器，或是其他只需要执行一次的复杂操作
   */
  bind: function(el, binding, vnode) {
    console.log('1 - bind');
  },
  // 2.绑定到节点
  inserted: function(el, binding, vnode) {
    console.log('2 - inserted');
  },
  /**
   * 3.组件更新
   * 根据获得的新值执行对应的更新
   * 对于初始值也会调用一次
   */
  update: function(el, binding, vnode, oldVnode) {
    console.log('3 - update');
  },
  // 4.组件更新完成
  componentUpdated: function(el, binding, vnode, oldVnode) {
    console.log('4 - componentUpdated');
  },
  /**
   * 5.解绑
   * 做清理操作
   * 比如移除bind时绑定的事件监听器
   */
  unbind: function(el, binding, vnode) {
    console.log('5 - bind');
  }
})
/**
钩子函数
1、bind:只调用一次，指令第一次绑定到元素时调用，用这个钩子函数可以定义一个绑定时执行一次的初始化动作。
2、inserted:被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于document中）。
3、update:被绑定于元素所在的模板更新时调用，而无论绑定值是否变化。通过比较更新前后的绑定值，可以忽略不必要的模板更新。
4、componentUpdated:被绑定元素所在模板完成一次更新周期时调用。
5、unbind:只调用一次，指令与元素解绑时调用。
*/
```



### 批处理

```javascript
/**
 * 批处理构造函数
 * @constructor
 */
function Batcher() {
    this.reset();
}

/**
 * 批处理重置
 */
Batcher.prototype.reset = function () {
    this.has = {};
    this.queue = [];
    this.waiting = false;
};

/**
 * 将事件添加到队列中
 * @param job {Watcher} watcher事件
 */
Batcher.prototype.push = function (job) {
    if (!this.has[job.name]) {
        this.queue.push(job);
        this.has[job.name] = job;
        if (!this.waiting) {
            this.waiting = true;
            setTimeout(() => {
                this.flush();
            });
        }
    }
};

/**
 * 执行并清空事件队列
 */
Batcher.prototype.flush = function () {
    this.queue.forEach((job) => {
        job.cb();
    });
    this.reset();
};
```

1. 在事件initialize阶段，一个update queue被创建。在事件中调用setState方法时，状态不会被立即调用， 而是被push进Update queue中。 

2. 函数执行结束调用事件的close阶段，Update queue会被flush，这是新的状态才会被应用到组件上并开始后续的Virtual DOM更新，biff算法来对model更新。 

3. 当model被修改时，对应的watcher会被推入Update queue， 与此同时还会在异步队列中添加一个task用于flush 当前的Update queue。 

4. 这样一来，当前的task中的其他watcher会被推进同一个Update queue中。当前task执行结束后，异步队列下一个 task执行，update queue  会被 flush，并进行后续的更新操作。 

5. 会被 flush，并进行后续的更新操作。 

6. 为了让 flush 动作能在当前 Task 结束后尽可能早的开始，Vue 会优先尝试将任务 micro-task 队列，具体来说， 在浏览器环境中 Vue 会优 

7. 先尝试使用 MutationObserver API 或 Promise，如果两者都不可用，则 fallback 到 setTimeout。 

### vue组件通讯

🍊使用**prop**接收父组件传的数据，是**单向数据流**，子组件不可修改父组件数据。

🍊 **子组件修改父组件数据**：

1. 父组件传递方法，子组件通过prop接收，然后使用this.fn调用

2. 父组件声明函数，子组件使用$.parent.fn调用

3. 父组件调用子组件时通过v-on绑定事件，子组件使用`vm.$emit( event, […args] )`触发事件

4. 使用`vm.$on( event, callback )`监听事件，`vm.$emit( event, […args] )`触发事件

5. v-model实现数据的双向绑定，它是个语法糖。`Input元素`上本身有个`oninput事件`，这是`HTML5新增加`的，类似 onchange，每当输入框内容发生变化的时候，就会触发`Input事件`，然后把 Input 输入框中 value 值再次传递给 something。可在子组件中声明**model**属性来修改v-model默认的属性名和方法名，避免内部冲突

   ```javascript
   <input  v-bind:value="something" v-on:input="something =  $event.target.value">
   ```

##### v-model就是一个语法糖，

6. `.sync`   2.0-2.3 期间不能使用

   ```javascript
   // 子组件方法内调用
   this.$emit('update:show',false)
   // 父组件调用子组件时传递
   <demo :show.sync="show" ></demo>
   ```

7. 2.4 新增的；在子组件中使用`this.$attrs`获取未使用prop接受的父组件传递的所有参数，使用`this.$listeners`未接受的方法

8. provide/inject **实现跨级访问祖先组件的数据**.**provide 和 inject 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的。**

   ```javascript
   // 祖先组件
   provide () { 			
     return { 				
       datas: this.datas 			
     } 		
   }  
   // 孙子组件
   inject: ['datas']
   ```

   

9. eventBus

10. vuex

### vue首屏优化

1. 其实还是前端性能优化的步骤，通过fp fcp fmp的优化来提高vue首屏的优化。
2. 提取第三方库，缓存，减少打包体积
3. 固定module id，为了缓存
4. 路由懒加载
5. 开启gzip
6. 图片懒加载
7. 压缩加密合并
8. tree shaking 、scope hositing、  code spliting
9. babel 按需引入pollyfill

### vue编译原理

### complier

vue的模板编译是发生在`$mount`之后，通过complie方法，经过parse、optimize、generate方法，最后生成render函数来生成虚拟dom，虚拟dom通过diff算法来更新dom。

具体功能如下：

* parse函数解析template，将template转成ast
* optimize函数优化静态资源
* generate函数创建render函数字符串

生成render函数之后就会调用new Watcher函数，用来监听数据的变化，render函数就是数据监听的回调所调用的，结果就是重新生成vnode。

当这个 render 函数字符串在第一次 mount、或者绑定的数据更新的时候，都会被调用，生成 Vnode。

### 运行时



### vue-router原理

vue-router的原理就是更新视图而不重新请求页面。vue-router可以通过mode参数设置为三种模式：**hash模式、history模式**、abstract模式。

* **hash模式**：hash值等于url中#及其以后的内容。浏览器是根据hash值的变化，将页面加载到相应的DOM位置。锚点变化只是浏览器的行为，每次锚点变化后依然会在浏览器中留下一条历史记录，可以通过浏览器的后退按钮回到上一个位置。

* **History模式**：它是利用H5 History API来实现的。通过history.pushState方法来实现URL的跳转而无需重新加载页面。但是它的问题在于当刷新页面的时候会走后端路由，所以需要服务端的辅助来兜底，避免URL无法匹配到资源时能返回页面。

* **abstract模式**： 服务端下使用。使用一个不依赖于浏览器的浏览历史虚拟管理后台。

hash模式和history模式都是通过`window.addEventListenter()`方法监听`hashchange`和`popState`进行相应路由的操作。可以通过back、foward、go等方法访问浏览器的历史记录栈，进行各种跳转。而abstract模式是自己维护一个模拟的浏览器历史记录栈的数组。

##### 使用：

1. 安装
2. 引入
3. `new Router()`创建router实例
4. `app.use`使用`<router-link>`留坑
5. 创建vue实例时挂载router实例

##### 路由传参：

```javascript
// 第一种方式
// ---- 调用
this.$router.push({
  path: `/describe/${id}`,
})
// ---- 定义
{
  path: '/describe/:id',
}
// ---- 获取
this.$route.params.id
  
// 第二种方式
// ---- 调用
this.$router.push({
  name: 'Describe',
  params: {
    id: id
  }
})
// ---- 获取
this.$route.params.id

 
// 第三种方式   这种方式会在路由上以？后拼接参数显示
// ---- 调用  
  this.$router.push({
    path: '/describe',
    query: {
      id: id
    }
  })
// ---- 获取
this.$route.query.id
```

**param和query的区别：** 

* query传递的参数会通过问号以键值对的方式显示在url内。param不会。
* params是必传的，如果没有参数会导致跳转失败或者页面会没有内容。query则不会影响页面显示

##### 路由守卫：

* router.beforeEach(to,from,next) 全局前置守卫
* router.afterEach(to,from) 全局后置守卫

##### 路由懒加载原理: 结合vue的异步组件和webpack的代码分割实现的，原理就是通过promise来加载路由，利用了js的异步事件队列。

**注意：**在结合node层使用history模式时，可以使用connect-history-api-fallback中间件，避免url不匹配时出现404.

koa2-connect-history-api-fallback中间件设置白名单，保证后端路由或api的正常访问。

### 图片懒加载

#### 原理

现将图片的src设置为一张默认的图片，当js监听到图片出现在屏幕的可视范围内，再将图片的真实地址应用。 

##### 实现方式：

* promise
* setTimeOut
* $nextTick

### v-model

vue 指令

* parse把model指令解析到el.directives
* codegen执行genData调用，遍历 el.directives，获取每个指令对应的方法
* 获取指令方法就执行，model函数调用genDefaultModel
* genAssignmentCode根据参数描述生成代码

总结：v-modle实际为语法糖。v-model=”something”则表示将value值绑定在something上，当值发生改变时触发绑定的oninput事件。oninput事件绑定的函数是将触发oninput事件的目标（该input）的value值赋值给something这个变量。

### watch

原理就是调用了$watch对内部所有的方法就行监听。

### $watch

它允许观察对象的某个属性，当属性变化时执行回调。接受三个参数：expOrFn（要观测的属性），cb(回调函数)，options(可选的配置对象)。

它的本质就是创建了一个Watcher实例

### computed

实质上也是创建了一个Watcher实例

当模板中的某个值需要通过一个或多个数据计算得到时，就可以使用计算属性，还有计算属性的函数不接受参数；监听属性主要是监听某个值发生变化后，对新值去进行逻辑处理。

### vue-cli项目打包优化

* 路由懒加载
* 配置别名
* 第三方库按需加载
* uglifyjs-webpack-plugin 对代码进行压缩、上线清除console等
* webpack-deep-scope-plugin css-nano 进行tree-sharking
* dllplugin和dllreferanceplugin 优化webpack编译速度

## Node篇

### express和koa的区别

1. **异步事件处理**： express 是通过
2. 来实现的，koa1 是采用generator，koa2是采用async/await。js处理异步： callback ☞ promise  ☞ generator ☞ async/await。
3. **错误处理**：express是通过callback处理的，无法捕获深层次的错误。koa采用的try/catch捕获的，能更好的获取异常。
4. **总结**：koa相比与express的好处是：异步处理流程优化和错误捕获，并且拆出了express的router和view功能，使得框架更轻，缺点在于社区相对较小。

### koa原理

* **application**：入口文件，主要有两个函数`app.listen()`、`app.use()`。一个用来监听端口，一个用来使用中间件
* **context**：代理文件，用来代理request和response
* **request**：请求相关的操作
* **response**：相应相关的操作
* **koa-compose**：处理中间件的核心代码。

##### 中间件处理

app.use() 将中间件push到中间件数组中，然后在listen方法中通过调用compose方法进行集中处理。koa的中间件处理可以当做是洋葱模型。中间件数组中中间件的执行是通过递归的方式来执行，调用dispatch函数，从第一个开始执行，当有next方法时创建一个promise，等到下一个中间件执行结果后再执行next后端代码。当第二个中间件也有next方法时，依然会创建一个新的promise等待下一个中间件的执行结果，这也就是中间件next的执行原理，核心代码是` return Promise.resolve(fn(context, dispatch.bind(null, i + 1)));`，递归遍历，直到遍历完所有的中间件next，生成一个多层嵌套的promise函数。

```javascript
function compose (middleware) {
  if (!Array.isArray(middleware)) throw new TypeError('Middleware stack must be an array!')
  for (const fn of middleware) {
    if (typeof fn !== 'function') throw new TypeError('Middleware must be composed of functions!')
  }
  /**
   * @param {Object} context
   * @return {Promise}
   * @api public
   */
  return function (context, next) {
    // last called middleware #
    let index = -1
    return dispatch(0)
    function dispatch (i) {
      if (i <= index) return Promise.reject(new Error('next() called multiple times'))
      index = i
      let fn = middleware[i]
      if (i === middleware.length) fn = next
      if (!fn) return Promise.resolve()
      try {
        return Promise.resolve(fn(context, dispatch.bind(null, i + 1)));
      } catch (err) {
        return Promise.reject(err)
      }
    }
  }
}
```

### V8垃圾回收机制

v8的GC分为新生代和老生代：新生代存放存活时间短的变量，区域小回收频繁；老生代存放存活时间长的变量。

新生代回收机制是**scavenge**算法。将空间分为from和to两块，新创建的变量会手机线进入from，当from满时就会触发GC，将非存活变量释放掉，存活的变量放到to中，然后将to和from位置互换。反复执行，当空间to的内存达到25%时就会触发晋升，将存活的变量晋升到老生代中。 scavege算法存在一个问题，堆内存只能使用一半，空间交换时间。

老生代使用的是**Mark-Sweep**和**Mark-compact**。使用Mark-Sweep将非存活的对象进行标记，然后清除，这样就会出现不连续的内存空间，所以我们就需要使用到Mark-Compact，他是基于Mark-Sweep 实现的，他会将存活的对象移到另一块连续的堆内存空间内，然后将其余的空间进行清除。

新生代是广度优先遍历，老生代是深度优先遍历。

在scavenge算法中会使用到**扫描指针**和**存储指针**，用来进行from->to的实现。存储指针指向的是需要存储对象的位置，扫描指针用来从头开始扫描对象，扫描的对象有指向，就像指向的对象存储到存储指针的位置，然后存储指针后移，将扫描到对象所指向的对象都存储完毕后，扫描指针后移，知道扫描指针和存储指针重合，说明从from到to的过程结束。

### Node的事件循环

Node的事件循环是借助libuv来实现的，libuv是一个高性能事件驱动的程序，他本质就是一个大的while循环。nodejs有一个事件队列，然后交给libuv，也就是event loop中进行轮询，当有事件操作符时，就交给工作线程来进行处理，处理完毕后再交给event loop然后返回给事件队列，表示该事件处理完毕。

## webpack专题

#### webpack热更新

使用插件 webpack-dev-server  实现热更新

##### webpack 中hash、chunkhash、contenthash的区别

**hash**：跟整个项目的构建相关，只要项目里有文件更改，整个项目构建的hash值都会改变，并且全部文件使用同一个hash值。
**chunkhash**：它根据不同的入口文件进行依赖文件解析、构建对应的chunk，生成对应的哈希值。我们生产环境里把一些公共库和程序入口文件区分开，单独打包构建，只要我们不改变公共库的代码，就可以保证其哈希值不会受影响。
**contenthash**：具体到模块内容，只要模块内容不变，就不会重新构建，可以配合extra-text-webpack-plugin里的contenthash值。
webpack中的实现：比如webpack@4用mini-css-extract-plugin单独分离了css，然后插件中设置filename（  new MiniCssExtractPlugin({filename: 'static/css/[name].[contenthash:8].css'})  ） js的话就在output中设置filename
vue-cli中的实现：在vue.config.js里配置

#### 核心模块

```javascript
Entry: 指定webpack开始构建的入口模块，从该模块开始构建并计算出直接或间接依赖的模块或者库。
Output：告诉webpack如何命名输出的文件以及输出的目录
Module: 模块，在 Webpack 里一切皆模块，一个模块对应着一个文件。Webpack 会从配置的 Entry 开始递归找出所有依赖的模块。
Chunk：coding split的产物，我们可以对一些代码打包成一个单独的chunk，比如某些公共模块，去重，更好的利用缓存。或者按需加载某些功能模块，优化加载时间。在webpack3及以前我们都利用CommonsChunkPlugin将一些公共代码分割成一个chunk，实现单独加载。在webpack4 中CommonsChunkPlugin被废弃，使用SplitChunksPlugin
Loader：模块转换器，用于把模块原内容按照需求转换成新内容。
Plugin：扩展插件，在 Webpack 构建流程中的特定时机会广播出对应的事件，插件可以监听这些事件的发生，在特定时机做对应的事情。
```

#### 打包流程

```javascript
Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：

初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；
开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译；
确定入口：根据配置中的 entry 找出所有的入口文件；
编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；
完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；
输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；
输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。
```

#### 编译结果

```javascript
(function(modules) {
  // 模拟 require 语句
  function __webpack_require__() {
  }
  // 执行存放所有模块数组中的第0个模块
  __webpack_require__(0);
})([/*存放所有模块的数组*/])

- 重写_webpack_require文件加载模式，模仿commonjs规范实现
- 将所有的js文件都已键值对的方式存入一个对象中，由_webpack_require来调用
```

#### Loader

一个 Loader 的职责是单一的，只需要完成一种转换。将源文件经过loader的编译，处理成浏览器识别的代码，这个过程可能需要多个步骤，那么就需要多个loader来处理。

**如何编写loader**

```javascript
const loaderUtils = require('loader-utils');
module.exports = function(source) {
  // 获取到用户给当前 Loader 传入的 options
  const options = loaderUtils.getOptions(this);
  return source;
};
```

#### Plugin

webpack通过plugin机制让其配置更加灵活，它会在运行的生命周期中留下钩子，让plugin来监听这些生命周期钩子，在合适的时候来调用钩子进行文件的处理。

```javascript
- complier：包含了webpack环境中所有的配置信息，比如options、loaders、plugins等，可以理解为webpack的实例
- compilation：包含了当前的模块资源、编译生成资源、变化的文件等。
- Compiler 和 Compilation 的区别在于：Compiler 代表了整个 Webpack 从启动到关闭的生命周期，而 Compilation 只是代表了一次新的编译。
```

webpack的编译是通过事件流编译的。主要通过TapTable来实现插件的binding和applying，它是用于事件发布订阅执行的插件架构，是webpack用来构建钩子的库。

```javascript
- 调用complier.hooks.run.tap开始注册
- 创建compilation
- 基于配置创建chunks
- 使用parser解析chunks
- 使用module和dependency管理代码模块相互依赖
- 使用template基于compilation数据生成结果代码
```

#### 优化

```javascript
webpack的优化主要分为两块：**打包速度和打包后的包体积**。

**打包速度优化：**

1. 使用speed-measure-webpack-plugin 分析打包速度
2. 开启cache-control
3. 开启多核编译 happypack
4. 开启多进程编译 webpack-parallel-uglify-plugin
5. dllplugin和dllreferencePlugin用某种方法实现了拆分 bundles，同时还大大提升了构建的速度。
6. 使用name-all-modules-plugin 保证chunkid不变 持久化缓存

**优化包体积：**

1. 使用webpack-bundle-analyzer进行分析各个文件的大小进行对应处理
2. css-nano进行css tree的sharking ；webpack-deep-scope-plugin进行js的tree sharking
3. 第三方库按需加载
4. spliteChunks抽离公共文件
5. 进行文件的压缩 uglifyjs-webpack-plugin
6. babel按需加载 使用@babel/pollfiles
```

#### 总结

🍊webpack是一个**打包模块化**JavaScript的工具，它将一切文件都视为模块，通过loader编译转换文件，通过plugin注入钩子，最后将输出的资源模块组合成文件。🍊它主要的**配置信息**有entry、output、modules、plugins。🍊它的**编译过程**为：**第一步**先初始化参数，通过yargs将webpack.config.js和shell脚本的配置信息合并，进行参数的初始化；**第二步**利用初始化的参数创建complier对象，complier可以视为一个webpack的实例，存在于webpack从启动到结束的整个过程，它包含了webpack的module、plugin等参数信息，	然后调用complier.run方法开始编译。**第三步**根据entry配置信息找到入口文件，创建compilation对象，可以理解为webpack一次编译的过程，包含了当前编译环境的所有资源，包括编译后的文件。**第四步**通过配置信息，调用loader进行模块翻译，使用acorn将模块转换为AST，当遇到require依赖时，创建依赖并加入依赖数组，再找出依赖的依赖，递归异步的处理所有的依赖。**第五步**完成第四步后将得到所有模块的依赖关系和模块翻译后的文件，然后调用compilation.seal方法，对这些模块和根据模块依赖关系创建的chunk进行整理，将所有资源进行合并拆分等操作。这是最后一次能修改输出内容的地方。**第六步**根据配置信息中的output配置，进行最后模块的文件输出，指定输出文件名和文件路径。🍊webpack**打包输出**后的文件其实就是一个闭包，传入的参数是一个对象，键值为所有输出文件的路径，内容为eval包裹的文件内容；闭包内重写了模块的加载方式，自己定义了`__webpack_require__方法，来实现模拟的commonjs规范模块加载机制。🍊**loader**是单一职责，只进行一种类型的转换，它的主要作用就是将源文件模块进行翻译，转换为浏览器识别的代码，如果需要进行多步转换就要调用多个loader。编写自己的loader时需要引用官方提供的laoder-utils ，调用loaderUtils.getOptions(this)拿到webpack的配置参数，然后进行自己的处理。🍊**plugin**让webpack的机制更加灵活，它在编译过程中留下的一系列生命周期的钩子，通过调用这些钩子来实现在不同编译结果时对源模块进行处理。它的编译是基于事件流来编译的，主要通过taptable来实现插件的绑定和执行的，taptable主要是基于发布订阅执行的插件架构，是用来创建声明周期钩子的库。调用complier.hooks.run.tap开始注册，创建compilation，基于配置创建chunks，在通过parser解析chunks，使用模块和依赖管理模块之间的依赖关系，最后使用template基于compilation数据生成结果代码 🍊webpack的优化主要是对打包速度和包体积进行优化。**包体积优化**通过webpack-bundle-analyzer对输出文件进行分析，通过图形显示文件的大小，然后逐个分析处理。主要有1. tree-sharking 用到的插件有cssnano和webpack-deep-scope-plugin；2. 第三方库按需加载；3.路由懒加载；4. splitechunk抽离公共文件；5. 文件压缩加密 uglifyjs-webpack-plugin ；6. babel使用@babel/pollfile进行按需加载。**打包速度优化**通过speed-measur-webpack-plugin分析打包速度，然后对打包慢的loader开启cache-control，还可以使用happypack开启多核编译，使用webpack-parallel-uglify-plugin开启多进程编译，或者使用dllplugin和dllreferencePlugin实现拆分bundles，还能提高构建的速度，或者使用name-all-modules-plugin保证chunkid不变进行持久化缓存。

## 网络篇

# 从输入url到页面加载



**1. 从浏览器接收url到开启网络请求线程**（这一部分可以展开浏览器的机制以及进程与线程之间的关系）

**2. 开启网络线程到发出一个完整的http请求**（这一部分涉及到dns查询，tcp/ip请求，五层因特网协议栈等知识）

**3. 从服务器接收到请求到对应后台接收到请求**（这一部分可能涉及到负载均衡，安全拦截以及后台内部的处理等等）

**4. 后台和前台的http交互**（这一部分包括http头部、响应码、报文结构、cookie等知识，可以提下静态资源的cookie优化，以及编码解码，如gzip压缩等）

**5. 单独拎出来的缓存问题，http的缓存**（这部分包括http缓存头部，etag，catch-control等）

**6. 浏览器接收到http数据包后的解析流程**（解析html-词法分析然后解析成dom树、解析css生成css规则树、合并成render树，然后layout、painting渲染、复合图层的合成、GPU绘制、外链资源的处理、loaded和domcontentloaded等）

**7. CSS的可视化格式模型**（元素的渲染规则，如包含块，控制框，BFC，IFC等概念）

**8.** **JS引擎解析过程****（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等）**

**9. 其它（可以拓展不同的知识模块，如跨域，web安全，hybrid模式等等内容）**



## 浏览器是如何运作的

浏览器可以简单分为三块：**用户界面**、**浏览器引擎**、**渲染引擎**。

**用户界面**用于展示除标签页窗口之外的其他用户界面内容。**渲染引擎**负责渲染用户请求的页面。在用户界面和渲染引擎之间有一个**浏览器引擎**，用于在用户界面和渲染引擎之间传递数据。

渲染器下面还有很多小的功能模块，比如：负责网络请求的网络模块、用于解析和执行js的js解释器、还有数据存储持久层帮助浏览器存储各种数据（eg:cookie）。

渲染引擎可以说是一个浏览器的核心与灵魂。我们往往会把渲染引擎叫做浏览器的内核，不同浏览器使用的内核也不太一样。其中IE使用的是Trident、Firefox使用的Gecko、Safari使用的是Webkit并将其开源、Chrome是使用的基于webkit改造优化的Blink渲染引擎也将其开源、Opera和Edge使用的是Blink。可以看到Webkit项目的开源对浏览器的发展做了多大的贡献。

浏览器是运行在操作系统上的一个应用程序，每个应用程序必须至少启动一个进程来执行其功能，每个程序往往需要运行很多任务，进程就会创建一些线程来帮助它去执行这些小的任务。

>  **进程**是操作系统进行资源分配和调度的基本单元，可以申请和拥有计算机资源，进程是程序的基本执行实体。
>
> **线程**是操作系统能够进行运算调度的最小单位，一个进程中可以并发多个线程，每条线程并行执行不同的任务。

当我们启动某个程序时就会创建一个进程来执行任务代码，同时会为该进程分配内存空间，该应用程序的状态都保存在该内存空间里。当应用关闭时，该内存空间就会被回收。进程可以启动更多的进程来执行任务，由于每个进程分配的内存空间是独立的，如果两个进程间需要传递某些数据，则需要进程间通讯管道IPC来传递。很多应用程序都是多进程的结构，这样是为了避免某一个进程卡死，由于进程间的相互独立，这样就不会影响到整个应用程序。进程可以将任务分成更多细小的任务，然后通过创建多线程并行执行不同的任务。同一进程下的线程之间是可以直接通信共享数据的。

早期的浏览器并不是多进程的结构，而是一个单进程的结构，一个进程中大概有页面线程负责页面渲染和展示等，js线程执行js代码，还有其它各种线程。单进程的结构引发了很多问题：一是**不稳定**，其中一个线程的卡死可能会导致整个进程出问题，比如打开多个标签页，其中一个标签卡死可能会导致整个浏览器无法正常运行；二是**不安全**，浏览器之间是可以共享数据的，那js线程岂不是可以随意访问浏览器进程内的所有数据；三是**不流畅**，一个线程需要负责太多事情会导致运行效率的问题。所以为了解决以上这些问题，现在采用了多进程浏览器结构。根据不同进程功能来拆卸浏览器，我们可以将它分解为这样的结构：其中**浏览器进程**负责控制Chrome浏览器出标签页外的用户界面，包括地址栏、书签、后退和前进按钮，以及负责与浏览器的其他进程协调工作；**网络进程**负责发起接受网络请求；**GPU进程**负责整个浏览器界面的渲染；插件进程负责控制网站使用的所有插件，例如flash，这里的插件指的不是chrome应用市场的插件；渲染器进程用来控制显示tab标签内的所有内容，浏览器会在默认情况下为每个标签页创建一个进程（再启动chrome是可以选择进程模型，它有四种进程模型）

当在浏览器地址栏输入网络地址时，浏览器进程的UI线程会捕捉你的输入内容，如果访问的是网址则UI线程会启动一个网络线程来请求DNS进行域名解析，接着开始连接服务器获取数据；如果输入的不是网址而是一串关键词，浏览器就知道你是要搜索，于是就会使用默认配置的渲染引擎来查询。

**浏览器安全验证：**当网络线程获取到数据后会通过SafeBrowsing来检查站点是否是恶意站点，如果是则会提示警告页面，告诉你这个站点有安全问题，浏览器会阻止你的访问，当然也可以强行继续访问。SafeBrowsing是谷歌内部的一套站点安全系统，通过检测该站点的数据来判断是否安全，比如查看该站点的IP是否在谷歌的黑名单之内，当返回数据准备完毕并且安全校验通过时，网络线程会通知UI线程我准备好了。然后UI线程会创建一个渲染器进程Renderer Thread来渲染页面，浏览器进程通过IPC管道将数据传递给渲染器进程，正式进入渲染流程。

**DOM树构建：**渲染器进程接受到的数据也就是HTML。渲染器进程的核心任务就是把html、css、js、image等资源渲染成用户可以交互的web页面。渲染器进程的主线程将html进行解析，构造DOM数据结构。DOM也就是文档对象模型，是浏览器对页面在其内部的表示形式，是web开发程序员可以通过JS与之交互的数据结构和API。html首先通过tokeniser标记化，通过词法分析将输入的html内容解析成多个标记，根据识别后的标记进行DOM树构造，在DOM树构建过程中会创建document对象，然后以document的为根节点的DOM树，不断进行修改，向其中添加各种元素。

**渲染阻塞：**html代码中往往会引入一些额外的资源，比如图片、CSS、JS脚本等，图片和CSS这些资源需要通过网络下载或从缓存中直接加载，这些资源不会阻塞html的解析，因为他们不会影响DOM树的生成，但当HTML解析过程中遇到script标签，就会停止html解析流程，转而去加载解析并且执行JS。这是因为浏览器并不知道JS执行是否会改变当前页面的HTML结构，如果JS代码里用了document.write方法来修改html，之前的和html解析就没有任何意义了，这也就是为什么我们一直说要把script标签要放在合适的位置，或者使用async或defer属性来异步加载执行JS。

**Layout Tree：**在html解析完成后，我们就会获得一个DOM Tree（树），但我们还不知道DOM Tree上的每个节点应该长什么样子，主线程需要解析CSS，并确定每个DOM节点的计算样式，即使你没有提供自定义的CSS样式，浏览器会有自己默认的样式表，比如h2的字体要比h3的大。在知道DOM结构和每个节点的样式后，我们接下来需要知道每个节点需要放在页面上的哪个位置，也就是节点的坐标以及该节点需要占用多大的区域，这个阶段被称为layout布局，主线程通过遍历dom和计算好的样式来生成Layout Tree。Layout Tree上的每个节点都记录了x、y坐标和边框尺寸。这需要注意的是DOM Tree和Layout Tree并不是一一对应的，设置了display:none的节点不会出现在Layout Tree上，而在before伪类中添加了content值的元素content中的内容会出现在Layout Tree上，不会出现在DOM树里，这是因为DOM是通过HTML解析获得的，并不关系样式，而Layout Tree是根据DOM和计算好的样式来生成，Layout Tree是和最后展示在屏幕上节点是对应的。

**绘制（paint）：**现在我们已经知道了元素的大小形状和位置，但还不知道以什么样的顺序绘制（paint）这个节点，例如z-index这个属性会影响节点绘制的层级关系，如果按照dom的层级结构来绘制页面则会导致错误的渲染。所以为了保证在屏幕上展示正确的层级，主线程遍历Layout Tree创建一个绘制记录表（Paint Record），该表记录了绘制的顺序，这个阶段配称为绘制（Paint）。

**栅格化：**现在知道了文档的绘制顺序，终于到了该把这些信息转化成像素点显示在屏幕上了，这个行为被称为栅格化（Rastering）。chrome最早使用了一种很简单的方式，只栅格化用户可视区域的内容，当用户滚动页面时，再栅格化更多的内容来填充缺失的部分，这种方式带来的问题就是会导致展示延迟。现在chrome进行了优化升级，使用了一种更为复杂的栅格化流程叫做合成（compositing），合成是一种将页面各个部分分成多个图层，分别对其进行栅格化，并在合成器线程（compositor Thread）中单独进行合成页面，简单来说就是页面所有的元素按照某种规则进行分图层，并把图层都栅格化好了，然后只需要把可视区的内容组合成一帧展示给用户即可。

**layer tree：**主线程遍历Layout Tree生成layer tree，当Layer Tree生成完毕和绘制顺序确定后，主线程将这些信息传递给合成器线程，合成器线程将每个图层栅格化，由于一层可能想页面的整个长度一样大，因此合成器线程将他们切分为许多图块（tiles），然后将每个图块发送给栅格化线程（Raster Thread），栅格化线程栅格化每个图块，并将他们存储在GPU内存中，当图块栅格化完成后，合成器线程将收集成为 draw quads 的图块信息，这些信息里记录了图块字啊内存中的位置和在页面的那个位置绘制图块的信息，根据这些信息合成器线程生成一个合成器帧（Compositor Frame）然后合成器Frame（帧）通过IPC传递给浏览器进程，接着浏览器进程将合成器帧传送到GPU，然后GPU渲染展示到屏幕上。

当页面发生变化时，比如滚动了当前的页面，都会生成一个新的合成器帧，新的帧再传给GPU，然后再次渲染到屏幕上。

**总结：**浏览器进程中的网络线程请求获取到html数据后，通过IPC将数据传给渲染器进程的主线程，主线程将html解析构造DOM树，然后进行样式计算，根据DOM树和生成好的样式生成Layout Tree，通过遍历Layout Tree生成绘制顺序表，接着遍历Layout Tree生成layer tree，然后主线程将Layer Tree和绘制顺序表一起传给合成器线程，合成器线程按规则进行分图层，并把图层分为更小的图块（tiles）传给栅格化线程进行栅格化，栅格化完成后，合成器线程会获得栅格线程传过来的draw quads图块信息，根据这些信息合成器线程上合成了一个合成器帧，然后将该合成器帧通过IPC传回给浏览器进程，浏览器进程再传递给GPU进行渲染之后就展示到你的屏幕上。

**重绘重排：**当我们改变了一个元素的尺寸位置属性时，会重新进行样式计算（computed style）布局（layout）绘制（paint）以及后面的所有流程，这种行为成为重排。当改变了某个元素的颜色属性时不会重新触发布局，但还是会触发样式计算和绘制这就是重绘，我们可以发现重排和重绘都会占用主线程，还有JS也会运行在主线程，所以就会出现抢占执行时间的问题，如果你写了一个不断导致重排重绘的动画，浏览器则需要在每一帧都运行样式计算布局和绘制的操作。

**优化：**我们知道当前页面以每秒60帧的刷新率时才不会让用户感觉到页面卡顿，如果在运行动画是还有大量的JS任务需要执行，因为布局、绘制和js执行都是在主线程运行的，当在一帧的时间内布局和绘制结束后，还有剩余时间js就会拿到主线程的使用权，如果js执行时间过长，就会导致在下一帧开始时js没有及时归还主线程，导致下一帧动画没有按时渲染，就会出现页面的卡顿。

第一种优化方式：requestAnimationFrame，它会在每一帧被调用，通过回调API的回调，可以把js运行任务分成一些更小的任务块，在每一帧事件用完前暂停js执行归还主线程，这样的话在下一帧开始时，主线程就可以按时执行布局和绘制。  

第二种优化方式：栅格化的整个流程不占用主线程，只在合成器线程和栅格线程中运行，这就意味着它无需和js抢占主线程。如果反复进行重绘和重排可能会导致掉帧，这是因为有可能js执行阻塞了主线程，而CSS中有个动画属性transform，通过该属性实现的动画不会经过布局和绘制，而是直接运行在合成器线程和栅格线程，所以不会受到主线程中js执行的影响。更重要的是听过transform实现的动画由于不需要经过布局绘制样式计算等操作，所以节省了很多运算事件（方便实现负责的动画）

## 性能优化篇

结合`performance.timing`图进行分析

![1576464941593-ab9038f2-730c-4e24-b82a-129cc65529fd](https://cdn.nlark.com/yuque/0/2019/png/225909/1576464941593-ab9038f2-730c-4e24-b82a-129cc65529fd.png?x-oss-process=image%2Fresize%2Cw_1959)

#### 优化阶段

**1. app cache**： 开启缓存 cache-control > exprise > etag > last-modified 

**2. DNS**：减少DNS查找次数。开启资源DNS，但是数量不能过多，这样会加大浏览器解析DNS的时间。

**3. 网络请求**：

* 开启keep-alive保持连接

* 避免跳转，重定向

* 减小cookie体积
* 打包时将代码压缩、合并，进行css和js的tree-sharking
* 减少http请求
* 延迟加载
* Gzip
* 开启可缓存ajax
* 预加载  quicklink
* 根据用户网速，加载不同大小的资源

**4. 浏览器渲染**：

* 减少dom数量和dom的嵌套
* 优化图像、懒加载、不缩放
* 避免页面重绘重排
* 开启GPU加速，通过设置transform、滤镜等css属性让GPU提前加入渲染

#### 浏览器渲染过程

1. 获取到的DOM是分层的；

2. 对每个层的节点计算样式结果；

3. 为每个节点生成图形和位置 ，所谓的回流，重排`Layout`；
4. 将每个节点绘制填充到图层的位图中 叫做重绘`Paint`；
5. 图层作为纹理上传至GPU （纹理是由CPU上传的）；
6. GPU把多个图层生成到显示器上，叫做合成层 `Composite Layer`。

**总结：Layout => Paint =>  Composite Layers**

#### 重绘重排



### requestAnimationFrame 下一帧动画

### FP FCP FMP

**FP**: 仅有一个 div 根节点。

**FCP**: 包含页面的基本框架，但没有数据内容。

**FMP**: 包含页面所有元素及数据。

## 移动端优化

## Vue首屏优化

## 前端性能优化

## 页面层次的性能优化

## 网络层面的性能优化

## webpack的优化

### 总结

前端性能优化的方式可以从页面的加载流程开始，通过performanceTiming图来说，🍊**第一步**是**缓存优化**，手段有：强缓和协商缓存；cache-control和expires为强缓，它们都是通过设置过期时间，如果请求时间在这个范围内就直接从缓存中获取内容；etag和last-modified为协商缓存，etag在请求时会带上if-none-match（一个id值），服务端进行对比这个值是否变化，没变就返回304；last-modified是if-modified-since携带一个时间戳，服务端对比这个时间戳的值进行对比，没变也返回304。优先级为cache-control>expires>etag>last-modified。🍊**第二步**DNS解析，合理开启DNS，优化资源查找时间，但数量过多会增加浏览器DNS解析时间。🍊**第三步**TCP链接，网络请求，手段有：开启keep-alive保护链接、避免重定向、减小cookie体积、代码压缩合并和tree-sharking、较少网络请求数量、延迟加载预加载、gzip、根据网速加载不同的资源等。插播**三次握手四次挥手**。🍊**第四步**浏览器渲染，手段有：减少dom数量和多层嵌套、优化图像、懒加载、不缩放、避免页面重绘重排、开启GPU加速（设置transform、滤镜等css属性让GPU提前加入渲染）

🍊**重绘重排：** 浏览器内部的处理，dom载入domLoading=>dom树加载完成domInteractive=>加载资源domContentLoaded=>dom处理完毕domComplete，到此步浏览器的核心功能完成。Layout => Paint => Composite Layer。造成重排的元素有：删除或添加Dom、位置、尺寸、内容、初始化渲染、窗口尺寸等。重绘：仅修改背景色颜色等非几何属性。

浏览器内部的处理，dom载入`domLoading`=>dom树加载完成`domInteractive`=>加载资源`domContentLoaded`=>dom处理完毕`domComplete`，到此步浏览器的核心功能完成。Layout => Paint => Composite Layer。造成**重排**的元素有：删除或添加Dom、位置、尺寸、内容、初始化渲染、窗口尺寸等。**重绘**：仅修改背景色颜色等非几何属性。

**🍊页面性能指标**：

**FP**: 仅有一个 div 根节点。

**FCP**: 包含页面的基本框架，但没有数据内容。

**FMP**: 包含页面所有元素及数据。Ï

- **DNS查询耗时** :domainLookupEnd - domainLookupStart

- **TCP链接耗时** :connectEnd - connectStart

- **request请求耗时** :responseEnd - responseStart

- **解析dom树耗时** : domComplete- domInteractive

- **白屏时间** :responseStart - navigationStart

- **domready时间** :domContentLoadedEventEnd - navigationStart

- **onload时间** :loadEventEnd - navigationStart

**🍊三次握手四次挥手：**

**🍊RequestAnimationFrame**

**🍊webpack优化** 包体积、打包速度

**🍊vue优化**

## axios源码

##### 二次封装  -  拦截器

通过axios.create创建服务，请求拦截service.interceptors.request.use（修改请求头和添加loading），响应拦截service.interceptors.response.use（根据状态吗做相应的处理，简化相应数据  res.data.data）

#####  方法

axios#request(config)

axios#get(url[, config])

axios#delete(url[, config])

axios#head(url[, config])

axios#options(url[, config])

axios#post(url[, data[, config]])

axios#put(url[, data[, config]])

axios#patch(url[, data[, config]])

axios#getUri([config])

##### Ajax, Axios, Fetch区别

🍊 **ajax**是原生XHR的封装，主要使用在jq（体积大）框架下，针对mvc框架

🍊 **axios**本质也是对XHR的封装，增加了promise 更加符合es规范，接口更丰富，体积小支持并发，完善度高，兼容性好，支持并发**axios.all**

🍊 **fetch**基于原生的XMLHttpRequest对象来实现数据请求的，同时也是基于Promise实现链式调用的。**好处：**更加底层、脱离了xhr是es规范的新的实现方式、跨域处理（配置中的mode设置为no-cors），**缺点**是默认不带cookie 需添加配置fetch(url, {credentials: 'include'})、不支持超时控制、不支持请求进度监视、兼容性不好不支持ie等

## Typescript

##### js的问题

- js语言本身的特性，决定了它无法适应大型的复杂项目

- 弱类型：可以修改变量的数据类型

- 解释型：只有在运行时才会确定语言的正确性

- 使用了不存在的变量、函数或成员

- 把一个不确定的类型当做一个确定类型处理

- 在使用对象的属性时，而这个对象却是null或者undefined

##### 好处

- 超集：包含了js的所有功能
- 提供了泛型、类、接口、装饰器等 就有

- 类型系统：对代码中所有的标识符（变量、函数、类型、返回值）进行类型检查。类型检查是在编译的时候，而非运行时

- 可选的：可用可不用

- 静态的：无论是浏览器还是node，都无法直接识别ts代码。
- 对开发者有严禁的约束，方便团队协作

##### 缺点

* 成本大，适合大型项目
* 浏览器不能直接识别，需要编译
* 周边不够完善，很多类库对ts的支持不够好，在判断类型时很难

##### 数据类型：

**🍊基本数据类型：** number、string、boolean、types[]/Array<types>、object、null和undefined

🍊 **其他类型：**联合类型、void类型、never类型、字面量类型、元祖类型、any类型、枚举类型、泛型



## 个人介绍

在特微主要是做车主服务的，主要业务是会员卡的售卖和会员服务，平台是微信公众号和支付宝服务号，都是移动端的项目。主要的技术栈node+ejs vue+vant。目前在做的项目是重庆etc服务的公众号，主要是etc的办理和一些服务。之前一牧主要是做牧场生产管理，数据分析的。主要是pc端的。技术栈jq vue node echarts bootstrapt layui。



主要负责项目的搭建  开发的规范以及问题的解决



css盒模型

promise.then的原理

