# https详解

超文本传输安全协议（https，常称为http over TLS/SSL）是一种通过计算机网络进行安全通信的传输文本，https经由http进行通信，但使用SSL/TLS来加密数据包，HTTPS开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私和完整性。

## TLS/SSL

- TCP（Transmission Control protocol）传输层控制协议
- TLS（Transport Layer Security）传输层安全协定
- SSL（Secure socket Layer）安全套接层

HTTP（HyperText Transfer protocol）基于TCP协议，无连接，每次连接只处理一个请求，结束后断开连接，无状态，无法保证用户状态，使用cookie和session解决

HTTPS（HTTP over TLS/SSL）安全的http协议，http协议和TCP协议之间添加了TLS/SSL保证数据的安全传输

## HTTPS安全性

HTTP协议的不安全性体现在三个方面

|   风险   |             描述             | https解决方案 |
| :------: | :--------------------------: | :-----------: |
| 窃听风险 |    攻击者可以获取消息内容    |   消息加密    |
| CA不可信 |      信任的CA乱签发证书      |    证书锁     |
| 冒充风险 | 攻击者可以冒充其他人参与通信 |  CA身份认证   |

- 窃听/嗅探

  指的是路由上的攻击，可以偷窥到传输的消息内容

  解决方案：

  1. 使用对称加密算法加密通信内容，窃听者获取到消息也无法识别，存在问题：密钥传递的安全性，在网络上的通信双方都是陌生人，无法识别身份，密钥要通过网络传输时很有可能被窃取。
  2. 使用非对称加密算法加密通信内容，发布的公钥用来加密，私钥用来解密，即使公钥被窃取，依然无法解密消息内容，存在问题：速度慢，公钥被公开，如果回发私钥加密的信息，任何持有公钥的人都可以解密
  3. 最终，消息内容仍旧使用对称加密算法来加密，但是前期对称加密的密钥使用非对称加密来进行，客户端使用服务端公钥加密对称加密的密钥，这样就只有拥有私钥的服务端可以获取到加密内容，由于对称加密密钥长度有限，加密的时间可以忽略不计。

  以上，可以防止嗅探的问题，路由上面的攻击即使获取到消息也无法识别消息的内容。

- 消息篡改

  消息加密以后攻击者无法获取消息内容的含义，但是可以篡改消息内容，篡改以后接收方也无法感知。

  解决方案：

  - 采用消息摘要算法可以验证数据的完整性，我们将发送的消息进行摘要，连同消息一起发送给接收方，接收方拿到消息之后对消息做同样的摘要处理，对比摘要结果，即可知道消息有没有被篡改。

  以上，可以解决消息完整性和真实性问题。

- 中间人攻击

  中间人攻击指的是攻击者在链路上伪装自己，与通讯双方分别建立联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制

  作为A和B通信路由上的攻击者M，作为中间人伪造自己的身份，A向B请求用于通信的PK_A，但是被中间人M截获，他伪造了假的公钥PK_M，发送给了A，同时向B请求并获取了B的公开密钥PK_B，原来安全的通信过程现在有了B整个中间人，出现问题的原因在于，密钥在交换的初期是不安全的，网络上的通信双方，无法确定对方的身份，即无法获取当前的公钥是不是自己想要的公钥。

  解决方案：

  - 服务端将自己的消息（消息内容大概包括电子签证机关的信息，公钥用户信息，公钥，权威机构的签字和有效期等）进行摘要以后，发给CA机构签发证书，服务端使用自己的私钥对消息进行摘要加密，形成证书，并将证书和消息内容发送给客户端，客户端收到后，发现是CA机构的证书，同时对CA机构是信任的，则会使用CA机构的公钥证书进行解密，获取到消息摘要，同时对收到的消息进行摘要，对比，如果一致则说明内容没有被篡改，是可信的，因为生成加密数据的私钥只有CA机构才有，这一过程称为数字签名。

  以上，可以解决中间人攻击。

- CA错误签发

  受信任的CA有好几百个，他们成为整个网站身份认证过程中一个较大的攻击面，实际上，目前由于CA失误导致错误签发证书，以及个别CA处于某些目的故意向第三方随意签发证书这两种情况时有发生，现有的证书信任链机制最大的问题是，任何一家受信任的CA都可以签发任意网站的站点证书，这些证书在客户端看来，都是合法的，是可以通过验证的。

  解决方案：

  - 证书锁：证书锁是为了防范由伪造或不正当手段获得网站证书造成的中间人攻击。
  - 证书锁给予我们主动选择信任CA的权力，它的工作原理就是使用预先设置的证书指纹和服务器传过来的证书链中的证书指纹进行匹配，只要有任何一对指纹匹配成功，则认为是一次合法的连接，否则禁止本次连接
  - 也就是说，使用证书以后，不是所有被系统信任的CA都可以通过验证，只有我保存了指纹的一些CA签发的证书才可以，比如由100个CA机构，但我就信任其中一个，我可以保证这个CA不会乱签发证书，那我就只保存这个CA的指纹，即使攻击者从其他的99个CA签发证书，对我进行攻击，也无法完成连接。
  - 证书锁定增价了安全性，但限制了你的服务器团队升级TLS证书的能力。

  以上，可以解决CA机构签发证书权威性不足的问题。

综上，对称加密通信+非对称加密交换密钥+CA认证身份+证书锁锁定证书指纹 共同保证了https的安全性。

## CA安全性

作为全网https连接的权威公正，CA的安全性至关重要。

- 安全保存CA

  从根CA开始直到给客户发放证书的各层次CA，都有其自身的密钥对，CA中心的密钥对一般由硬件加密服务器在机器内直接产生，并存储于加密硬件内，或以一定的加密形式存放于密钥数据库内，加密备份于IC卡或其他存储介质中，并以高等级的物理安全措施保护起来。所以CA密钥的安全性依赖于物理硬件的安全性，不通过网络传输，避免了被攻击的可能。

- 证书链

  现在大的CA都会由证书链，证书链的好处一是安全，保持根CA的私钥离线使用，第二个好处是方便部署和撤销，即如果证书出现问题，只需要撤销相应级别的证书，根证书依然安全。

  根CA证书都是自签名，即用自己的公钥和私钥完成了签名的制作和验证，而证书链上的证书签名都是使用上一级证书的密钥对完成签名和验证的。

- 证书验证

  证书是否是信任的证书

  1. 是否信任：接收方内置了信任根证书的公钥，需要证书是不是这些信任根证书签发的或者信任根证书的二级证书机构颁发的。
  2. 是否有效：证书是否在有效期内。
  3. 是否合法：对方是不是上述证书的合法持有者，证明对方是否持有证书的对应私钥，验证方法两种，一种是对方签个名，我用证书验证签名，另外一种是用证书做个信封，看对方是否能解开。
  4. 是否吊销：验证是否吊销可以采用黑名单方式或者OCSP方式，黑名单就是定期从CA下载一个名单列表，里面有吊销的证书序列号，自己在本地对比一下就行，优点是效率高，缺点是不实时，OCSP是实时连接，优点是实时，缺点是效率不高。

## 自签名证书如何验证

自签名证书是自己给自己签发的证书，也就是说自己做自己的CA机构，为自己担保，因此无法内置在系统中，因此我们通常会在客户端内置一个证书文件，自己进行校验。

简单来说，握手流程需要两对密钥对：

1. 一对CA的密钥对，由CA机构维护，通常他的公钥内置在操作系统中，用来签名服务器信息摘要，保证服务端公钥的真实性，避免中间人攻击。
2. 一对服务器的密钥对，他是握手过程中随机生成的，然后用他的公钥及其他内容的摘要去向CA实时签发证书，用来进行对称密钥的加密传输。

自签名证书就是不走CA机构，而是自己生成一对密钥，他的作用就好比CA的密钥对，也是为了保证公钥的真实性，握手过程跟原来一样，只是我们不需要去CA签发证书了，用自己的签发就可以了，同样因为公钥没有内置在操作系统中，所以此时需要我们自己把cert文件放到本地，自己完成原来由CA完成的CA校验任务。

## HTTPS握手

1. 客户端向服务器发送握手信息，告知自己支持的加密算法，摘要算法，安全层协议版本。
2. 服务端随机生成本次握手需要的非对称加密的密钥对（私钥+公钥），将来用来传输对称加密密钥。服务端生成消息，内容包含随机数，确定的一组加密算法和摘要算法，服务器公钥，域名信息等。服务端对消息内容摘要，使用摘要的信息向CA机构申请的签名证书。服务端向客户端发送消息和申请的证书，如果需要双向验证的话，请求客户端证书。
3. 验证服务端证书，提取服务器公钥。客户端从信任证书列表中发现是受信任的证书，会首先验证证书是否被信任，有效性，合法性等信息，验证过程参照上方的证书验证。验证通过，客户端使用CA机构的公钥对证书解密，拿到消息的摘要，对真正的消息内容进行摘要，对比确定消息没有被篡改，则取出服务端公钥，如果需要双向验证的话，向服务端发送自己的证书。客户端随机生成数字，将其进行摘要加密，使用服务端公钥对消息和摘要结果加密，发送给服务端，并发送一个编码改变通知，说明以后将会开始加密通信。
4. 生成对称加密密钥。服务端使用私钥对收到的信息解密，对消息进行摘要对比无误，则说明对称加密的密钥没有被篡改，然后生成最终将钥进行对称加密通信的密钥，服务器加密一段握手信息及其摘要，发送给客户端，并发送一个编码改变通知，说明以后将会开始加密通信
5. 客户端验证加密结果，握手结束。客户端生成同样的对称加密密钥，使用密钥解密，并验证信息摘要，没有问题则握手结束，后面的通信将会使用新生成的对称加密密钥加密进行。