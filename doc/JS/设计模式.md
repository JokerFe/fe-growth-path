[toc]

# 设计模式

> 在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案。

目的：设计模式是为了更好的代码**重用性**，**可读性**，**可靠性**，**可维护性**。

## 六大原则

#### 单一职责原则 SRP

> Single Responsibility Principle: There should never be more than one reason for a class to change.

一个类，最好只负责一件事，只有一个引起它变化的原因。**重点是职责的划分！**

#### 里氏替换原则 LSP

> Liskov Substitution Principle: If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T,the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T.
>
> 第二种定义：Functions that use pointers or references to base classes must be able to useobjects of derived classes without knowing it.
>

如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型S是类型T的子类型。

所有引用基类的地方必须能透明地使用其子类的对象。只要有父类出现的地方，都可以用子类来替代。

#### 依赖倒转原则 **DIP**

> Dependence Inversion Principle: High level modules should not depend upon low level modules. Both should depend upon abstractions. Abstractions should not depend upon details. Details should depend upon abstractions.

高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。 

#### 接口隔离原则 **ISP**

> Interface Segregation Principle: Clients should not be forced to depend upon interfaces that they don't use.
>
> 还有一种定义是The dependency of one class to another one should depend on the smallest possible interface.

其一是不应该强行要求客户端依赖于它们不用的接口；其二是类之间的依赖应该建立在最小的接口上面。简单点说，客户端需要什么功能，就提供什么接口，对于客户端不需要的接口不应该强行要求其依赖；类之间的依赖应该建立在最小的接口上面，这里最小的粒度取决于单一职责原则的划分。

#### 最少知识原则 LKP

> 迪米特法则 Law of Demeter  
>
> 英文简写： LoD.
>
> Least Knowledge Principle： talk only to your immediate friends.

一个类对于其他类知道的越少越好，就是说一个对象应当对其他对象有尽可能少的了解,只和朋友通信，不和陌生人说话。

#### 开放封闭原则 OCP

> Open Closed Principle: Software entities (classes, modules, functions) should be open for extension but closed for modification.

软件实体（包括类、模块、功能等）应该对扩展开放，但是对修改关闭。

## 单例模式

> 保证一个类仅有一个实例，并提供一个访问它的全局访问点，一般购物车、登录等都是一个单例。

```js
// es6
class SingleManage {
    constructor({ name, level }) {
        if (!SingleManage.instance) {
            this.name = name;
            this.level = level
            SingleManage.instance = this;
        }
        return SingleManage.instance
    }
}

let boss = new SingleManage({name:"Jokul", level:"1"})
let boss2 = new SingleManage({name:"Jokul2", level:"2"})
console.log(boss === boss2)

// es5
function SingleManage(manage) {
    this.name = manage.name
    this.level = manage.level
    this.info = function () {
        console.warn("Boss's name is " + this.name + " and level is " + this.level)
    }
}
SingleManage.getInstance = function (manage) {
    if (!this.instance) {
        this.instance = new SingleManage(manage)
    }
    return this.instance
}
var boss = SingleManage.getInstance({ name: "Jokul", level: "1" })
var boss2 = SingleManage.getInstance({ name: "Jokul2", level: "2" })
boss.info()
boss2.info()
```

应用场景：JQuery中的$、Vuex中的Store、Redux中的Store等

## **惰性单例**

> 指的是在需要的时候才创建对象实例。惰性单例是单例模式的重点

```js
var getSingle = function( fn ){
   var result;
   return function(){
       return result || ( result = fn.apply(this, arguments ) );
   } 
};
var createLoginLayer = function(){
    var div = document.createElement( 'div' );
    div.innerHTML = '我是登录浮窗';
    div.style.display = 'none';  
    document.body.appendChild( div );
    return div;
};
var createSingleLoginLayer = getSingle( createLoginLayer );
document.getElementById( 'loginBtn' ).onclick = function(){ 
    var loginLayer = createSingleLoginLayer(); 
    loginLayer.style.display = 'block';
};
```

应用场景：创建唯一的浮窗

## 代理模式

> 为其他对象提供一种代理，便以控制对这个对象的访问，不能直接访问目标对象。

下面实现一个功能：助理帮老板收取文件

```js
// es6
// 文件
class File {
    constructor(name) {
        this.name = name
    }
    getFile() {
        return this.name
    }
}

// 老板
class Boss {
    getFile(name) {
        console.log("收取到文件：" + name);
    }
}

// 助理
class Assistant {
    receiveFile(name) {
        new Boss().getFile(new File(name).getFile())
    }
}
new Assistant().receiveFile("员工花名册.excel")


// es5
var File = function (name) {
    this.name = name
}
File.prototype.getFile = function () {
    return this.name
}

// 定义一个助理
var assistant = {
    receiveFile: function (file) {
        Boss.getFile(file.getFile())
    }
}

// 定义一个老板对象
var Boss = {
    getFile: function (name) {
        console.log("收取到文件：" + name);
    }
}
assistant.receiveFile(new File("员工花名册.excel"))
```

应用场景：ES6 Proxy、Vuex中对于getters访问、图片预加载等

#### 虚拟代理实现图片预加载

```js
var myImage = (function(){
    var imgNode = document.createElement( 'img' );     
    document.body.appendChild( imgNode );
    return {
        setSrc: function( src ){
             imgNode.src = src; 
        }
    } 
})();
var proxyImage = (function(){ 
    var img = new Image; 
    img.onload = function(){
        myImage.setSrc( this.src ); 
    }
    return {
        setSrc: function( src ){
             myImage.setSrc( 'file:// /C:/Users/svenzeng/Desktop/loading.gif' );
             img.src = src;  
        }
    } 
})();
proxyImage.setSrc('http://imgcache.qq.com/music/photo/k/000GGDys0yA0Nk.jpg' );
```

#### 虚拟代理合并HTTP请求

> 假设我们在做一个文件同步的功能，当我们选中一个 checkbox 的时候，它对应的文件就会被同 步到另外一台备用服务器上面。当一次选中过多时，会产生频繁的网络请求。将带来很大的开销。可以通过一个代理函数 proxySynchronousFile 来收集一段时间之内的请求， 最后一次性发送给服务器

```js
var synchronousFile = function( id ){ 
    console.log( '开始同步文件，id 为: ' + id );
};
var proxySynchronousFile = (function(){
    var cache = [], // 保存一段时间内需要同步的 ID
    timer; // 定时器
    return function( id ){
        cache.push( id );
            if ( timer ){ // 保证不会覆盖已经启动的定时器
                 return; 
            }
        timer = setTimeout(function(){ 
            synchronousFile( cache.join( ',' ) ); 
            clearTimeout( timer ); // 清空定时器 
            timer = null;
            cache.length = 0; // 清空 ID 集合
        }, 2000 ); 
    }// 2 秒后向本体发送需要同步的 ID 集合
})();

var checkbox = document.getElementsByTagName( 'input' );
   for ( var i = 0, c; c = checkbox[ i++ ]; ){
      c.onclick = function(){
      if ( this.checked === true ){
          proxySynchronousFile( this.id ); }
      }
};
```



## 观察者模式

> 目标和观察者是基类，目标提供维护观察者的一些了方法，观察者提供更新接口。具体观察者和具体目标继承各自的基类，然后具体观察者把自己注册到目标里，在哭啼目标发生变化时候，调度观察者更新方法。

```js
// es6
class Subject {
    constructor() {
        this.state = 0;
        this.observers = []
    }
    getState() {
        return this.state
    }
    setState(state) {
        this.state = state;
        this.notify();
    }
    notify() {
        this.observers.forEach(observer => {
            observer.update()
        })
    }
    add(observer) {
        this.observers.push(observer)
    }
}

class Observer {
    constructor(name, subject) {
        this.name = name;
        this.subject = subject;
        this.subject.add(this)
    }
    update() {
        console.warn(`${this.name} 被更新，状态为${this.subject.getState()}`)
    }
}

let sub = new Subject();
let ob = new Observer("ob", sub); 

sub.setState(1)

// es5
var Subject = function () {
    this.state = 0;
    this.observers = []
}
Subject.prototype.getState = function () {
    return this.state
}
Subject.prototype.setState = function (state) {
    this.state = state;
    this.notify();
}
Subject.prototype.notify = function () {
    this.observers.forEach(observer => {
        observer.update()
    })
}
Subject.prototype.add = function (observer) {
    this.observers.push(observer)
}
var Observer = function (name, subject) {
    this.name = name;
    this.subject = subject;
    this.subject.add(this)
}
Observer.prototype.update = function () {
    console.warn(`${this.name} 被更新，状态为${this.subject.getState()}`)
}
var sub = new Subject();
var ob = new Observer("ob", sub);

sub.setState(1)
```

应用场景：JS事件、JS Promise、JQuery.$CallBack、Vue watch、NodeJS自定义事件，文件流等

## 发布者订阅者模式

> 订阅者把自己想要订阅的事件注册到调度中心，当该事件触发时候，发布者发布该事件到调度中心，由调度中心统一调度订阅者注册到调度中心的处理代码。

具体代码可参考[简易版MVVM](https://github.com/Jokul518/fe-growth-path/tree/master/简易版MVVM)

**注：观察者模式与发布者订阅者模式的区别：本质上的区别是调度的地方不同。**观察者由具体的目标调度，而发布者订阅者模式是统一由调度中心调用，所以观察者模式的订阅者和发布者之间存在依赖，而发布者订阅者模式则不会。

## 装饰器模式

> 在不改变对象自身的基础上，动态的给某个对象添加新的功能，同时又不改变其接口。

在ES7中，新增了装饰器的概念，它是一种与类相关的语法，用来注释或修改类和类方法的。在Typescript中也有装饰器的概念，它能够带来额外的信息，可以达到分离关注点的目的。Typescript装饰器分为类装饰器、属性装饰器、方法装饰器和参数装饰器，具体的使用方法就不在这里讨论了，可参考文章[Typescript之装饰器](https://www.yuque.com/guohh/rnkw5u/yf8c5c)。下面主要实现ES7中的装饰器实现方式：

```js
class Before {
    bef() {
        console.warn("执行了前置钩子")
    }
}

class FN {
    constructor(before) {
        this.before = before;
    }
    imp() {
        this.before.bef();
        console.warn("执行了主函数")
    }
}
let before = new Before()
let fn = new FN(before);
fn.imp()
```

在es5的时代，可以利用面向切面AOP的思路给函数动态添加功能，比如Function的before或者after

```js
Function.prototype.before = function (beforeFN) {
    var _self = this;
    return function () {
        beforeFN.apply(_self, arguments)
        return _self.apply(this, arguments)
    }
}

Function.prototype.after = function (afterFN) {
    var _self = this;
    return function () {
        var fn = _self.apply(this, arguments);
        afterFN.apply(_self, arguments)
        return fn
    }
}

var func = function () {
    console.warn("func")
}

func = func.before(function () {
    console.warn("前置钩子")
}).after(function () {
    console.warn("后置钩子")
})

func()
```

应用场景：ES7装饰器、Vuex中1.0版本混入Vue时，重写init方法、Vue中数组变异方法实现等。

## 策略模式

#### 表单校验

```js
var strategies = {
    isNonEmpty: function( value, errorMsg ){
        if ( value === '' ){ 
            return errorMsg ;
        } 
    },
    minLength: function( value, length, errorMsg ){ 
        if ( value.length < length ){
            return errorMsg;
        }
    },
    isMobile: function( value, errorMsg ){ // 手机号码格s's's式
        if ( !/(^1[3|5|8][0-9]{9}$)/.test( value ) ){ 
            return errorMsg;
        } 
    }
};
var Validator = function(){
    this.cache = []; // 保存校验规则
};
Validator.prototype.add = function( 
    var ary = rule.split( ':' ); 
    this.cache.push(function(){ //
        var strategy = ary.shift(); 
        ary.unshift( dom.value ); 
        ary.push( errorMsg ); // 
        return strategies[strategy].apply(dom, ary);
    }); 
};
Validator.prototype.start = function(){
    for ( var i = 0, validatorFunc; validatorFunc = this.cache[ i++ ]; ){
        var msg = validatorFunc(); // 开始校验，并取得校验后的返回信息 
        if ( msg ){ // 如果有确切的返回值，说明校验没有通过
              return msg; 
        }
    }
};
var validataFunc = function(){
    var validator = new Validator(); // 创建一个 validator 对象
    /***************添加一些校验规则****************/
    validator.add( registerForm.userName, 'isNonEmpty', '用户名不能为空' );           
    validator.add( registerForm.password, 'minLength:6', '密码长度不能少于 6位');     
    validator.add( registerForm.phoneNumber, 'isMobile', '手机号码格式不正确' );
    var errorMsg = validator.start(); // 获得校验结果
    return errorMsg; // 返回校验结果 
}
var registerForm = document.getElementById( 'registerForm' ); registerForm.onsubmit = function(){
    var errorMsg = validataFunc(); // 如果 errorMsg 有确切的返回值，说明未通过校验 
    if ( errorMsg ){
        alert ( errorMsg );
        return false; // 阻止表单提交 
    }
};
```

## **迭代器模式**

> 迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。迭代器模式可以把迭代的过程从业务逻辑中分离出来,在使用迭代器模式之后，即使不关心对象的内部构造，也可以按顺序访问其中的每个元素。

```js
var each = function( ary, callback ){
    for ( var i = 0, l = ary.length; i < l; i++ ){
         callback.call( ary[i], i, ary[ i ] );
    }
};
each( [ 1, 2, 3 ], function( i, n ){ 
    alert ( [ i, n ] );
});
```

## **命令模式**

> 命令模式是最简单和优雅的模式之一，命令模式中的命令(command)指的是一个执行某些特定事情的指令

应用场景：有时候需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是什么。此时希望用一种松耦合的方式来设计程序，使得请求发送者和请求接收者能够消除彼此之间的耦合关系。

案例：  假设我们正在编写一个用户界面程序，该用户界面上至少有数十个 Button 按钮。因为项目比较复杂，所以我们决定让某个程序员负责绘制这些按钮，而另外一些程序员则负责编写点击按钮后的具体行为，这些行为都将被封装在对象里。

在大型项目开发中，这是很正常的分工。对于绘制按钮的程序员来说，他完全不知道某个按钮未来将用来做什么，可能用来刷新菜单界面，也可能用来增加一些子菜单，他只知道点击这个 按钮会发生某些事情。那么当完成这个按钮的绘制之后，应该如何给它绑定onclick 事件呢?

我们很快可以找到在这里运用命令模式的理由:点击了按钮之后，必须向某些负责具体行为的对象发送请求，这些对象就是请求的接收者。但是目前并不知道接收者是什么对象，也不知道接收者究竟会做什么。此时我们需要借助命令对象的帮助，以便解开按钮和负责具体行为对象之间的耦合.

```js
var RefreshMenuBarCommand = function( receiver ){
     return {
         execute: function(){ 
             receiver.refresh();
         }
     } 
 };
 var setCommand = function( button, command ){ 
     button.onclick = function(){
         command.execute(); 
     }
 };
 var refreshMenuBarCommand = RefreshMenuBarCommand( MenuBar );         
 setCommand( button1, refreshMenuBarCommand );
```



## 其他设计模式

* 组合模式
* 中介者模式
* 职责链模式
* [更多参考](https://www.runoob.com/design-pattern/design-pattern-tutorial.html)