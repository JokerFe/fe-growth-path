# 双指针

## 快慢指针

> 主要解决链表中的问题

### [142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)

```
给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。
不允许修改 链表。

示例 1：
输入：head = [3,2,0,-4], pos = 1
输出：返回索引为 1 的链表节点
解释：链表中有一个环，其尾部连接到第二个节点。

示例 2：
输入：head = [1,2], pos = 0
输出：返回索引为 0 的链表节点
解释：链表中有一个环，其尾部连接到第一个节点。

示例 3：
输入：head = [1], pos = -1
输出：返回 null
解释：链表中没有环。

提示：
链表中节点的数目范围在范围 [0, 104] 内
-105 <= Node.val <= 105
pos 的值为 -1 或者链表中的一个有效索引
```

当快慢指针相遇时，让其中一个指针重新指向头节点，然后让他俩以相同速度前进，再次相遇时的节点位置就是环开始的位置。

第一次相遇， 慢指针走了k步，快指针走了2k步，那么环的长度就是k。

设相遇点到环起点的距离为X， 则环起点距离头节点的距离为K-X。

那么其中一个指针重新指向head，然后相同速度前进，K-X之后必然相遇，相遇点就是环起点.

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var detectCycle = function(head) {
    if (head == null || head.next == null || head.next.next ==null) return null
    let fast = head;
    let slow = head;
    while(fast != null && fast.next != null) {
        fast = fast.next.next;
        slow = slow.next;
        if (fast == slow) break;
    }
    if (fast != slow)  return null
    slow = head;
    while(slow != fast) {
        slow = slow.next;
        fast = fast.next;
    }
    return slow;    
};
```

## 左右指针（对撞指针）

> 主要解决数组或者字符串中的问题

### [15. 三数之和](https://leetcode.cn/problems/3sum/)

```
给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。
注意：答案中不可以包含重复的三元组。

示例 1：
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]

示例 2：
输入：nums = []
输出：[]

示例 3：
输入：nums = [0]
输出：[]

提示:
0 <= nums.length <= 3000
-105 <= nums[i] <= 105
```

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var threeSum = function(nums) {
    const len = nums.length;
    if (nums == null || len < 3) return []
    let res = []
    nums.sort((a, b) => a - b);
    for(let i = 0; i < len;i++) {
        if (nums[i] > 0) break;
        if (i > 0 && nums[i] == nums[i-1]) continue
        let l = i + 1;
        let r = len - 1;
        while(l < r ) {
            const sum = nums[i] + nums[r] + nums[l];
            if (sum == 0) {
                res.push([nums[i], nums[r], nums[l]]);
                while(l<r && nums[l] == nums[l+1]) l++
                while(l<r && nums[r] == nums[r-1]) r--
                l++;
                r--;
            } else if (sum < 0) {
                l++;
            } else {
                r--;
            }
        }
    }
    return res
};
```

## 滑动窗口

>  又叫**尺取法**

可以用来解决一些查找满足一定条件的连续区间(长度)性质的问题

由于区间连续，因此区间发生变化时，可以通过旧有的计算结果对搜索空间进行剪枝，这样可以减少重复计算，降低事件复杂度

### [3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

```
给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。

示例 1:
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。

示例 2:
输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。

示例 3:
输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。

提示：
0 <= s.length <= 5 * 104
s 由英文字母、数字、符号和空格组成
```

```js
/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLongestSubstring = function(s) {
    if (s.length < 2 ) return s.length
    const arr = s.split('');
    let maxLen = 1;
    let L = 0;
    let R = 1;
    let _tempSet = new Set()
    _tempSet.add(arr[L])
    while(L <= R && R < arr.length) {
        const curR = arr[R]
        if (!_tempSet.has(curR)) {
            _tempSet.add(curR)
            maxLen = Math.max(maxLen, R - L + 1);
            R++;
        } else {
            _tempSet.clear();
            L++;
            R = L + 1;
            _tempSet.add(arr[L])
        }   
    }
    return maxLen
};
```

